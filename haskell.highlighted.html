<meta charset="utf-8">
en.wikibooks の <a href="http://en.wikibooks/org/wiki/Haskell">Haskell</a> をベースに．<br />
wikibooks のライセンスを継承して CC-BY-SA です．
<h2>Getting set up</h2>
<p>
まずは haskell のインストール． Glasgow Haskell Compiler, GHC がおすすめ．<br />
ちなみにこの GHC自体も Haskell で書かれてるらしい<small>（だからソースから自分でビルドしようとするとめっちゃ苦労するらしい）</small>．<br />
ubuntu とかなら
<pre style="background:#000;color:#f8f8f8">
$ sudo apt-get update
$ sudo apt-get install ghc
</pre>
でよい． コンパイラとともに GHCi (i for <i>interacitve</i>)という interactive environment がついてきます．<br />
若干 python とかのインタープリタとは趣が違うんやけど，まあともかくこの人とお話していきましょう．<br />
linux ならたとえば
<pre style="background:#000;color:#f8f8f8">
$ ghci
GHCi, version 7.6.2: <span style="color:#e18964;text-decoration:underline">http://www.haskell.org/ghc/</span>  :? for help
Loading package ghc-prim ... linking ... done.
Loading package integer-gmp ... linking ... done.
Loading package base ... linking ... done.
Prelude> 
</pre>
というかんじ．<small>かっこいいアスキーアートが出てくる例が多いみたいやけどなんか僕の環境では出てきません． </small><br />
ここで <code> loading package </code>とかやってくれてますが，<br />
これによって built-in functions や modules にはだいたいアクセスできる．<br />
<code>Prelude></code> は prompt ってやつで，ここにコマンドを書き込んでいく．<small>prelude の意味はそのうち出てくるはず．</small><br />
</p>
<p>
というわけで四則とかそのへん．まだすごくない．
<pre style="background:#000;color:#f8f8f8">
Prelude> 2+2
4
Prelude> 5 * 4 + 3 
23
Prelude> 2^5
32
</pre>
指数は <code>^</code>で書くぜってあたり以外は特記事項なし．<br />
...と思ってたら， <code>^</code> は <code>(Integral b, Num a) => a -> b -> a </code>. <br />
<small>（この記法の意味はしばらく先に出てきます．とりあえずは数なものと Integral なもの（こっちが第2引数）を受け取って数を返す（数学で言う）函数ってこと．）</small><br />
例えば
<pre style="background:#000;color:#f8f8f8">
Prelude> 2^1.2
</pre>
はエラーを，
<pre style="background:#000;color:#f8f8f8">
Prelude> 2^(-1)
</pre>
は Exception を返してくるみたい．<br />
こういうのも含めて指数を書くときは <code> ** </code> で．
<pre style="background:#000;color:#f8f8f8">
Prelude> :t (**)
(**) :: Floating a => a -> a -> a
</pre>
まとめると
<pre style="background:#000;color:#f8f8f8">
Prelude> 2**(-1)
0.5
Prelude> 2**0.5
1.4142135623730951
Prelude> 1.0^2
1.0
</pre>
これからお世話になる ghci はソースファイル読み込んだりとかもちゃんとできる優秀なひと，らしい．
</p>

<p><h2>Variables and functions</h2>
さっきのは単にその場所で計算しっぱなしやったけど，これは不便よね．<br />
というわけでそういうのは value をもつ variable に保存されます．例えば半径5の円の面積
<pre style="background:#000;color:#f8f8f8">
ghci>3.1416 * 5^2
78.53999999999999
</pre>
<small>#これ<code>ghci></code>ってなってるけどたとえば <code>Prelude></code> でやっていい．</small><br />
やけど，いちいち打ち込むのはあんまりです．<br />
この場合すでに pi っていう variable が define されてて，
<pre style="background:#000;color:#f8f8f8">
ghci> pi
3.141592653589793
ghci> pi * 5^2
78.53981633974483
</pre>
善哉．<br />
この辺りで最後に表示されるのは結局，式とか函数を評価していって最後に値がひとつ残った時にそれを表示，ということが行われてます．<br />
なお Haskell に変数はない，という言い方も多い（値を "束縛" することはあっても，それを変化させられないから）けど，<br /> 
ここではとりあえず variable と呼んでおきます．なんかもう全部（数学で言う）関数みたいなもん，みたい．
</p>
<h3>Haskell source files</h3>
<p>ではでは僕らも変数を定義してみよう．と，いうところで…
<pre style="background:#000;color:#f8f8f8">
Prelude> r = 3
</pre>
と何も考えずにやると
<pre style="background:#000;color:#f8f8f8">
Prelude> r = 3

&lt;interactive>:9:1: parse error on input '='
</pre>
怒られました．このあたりが python のインタープリタと根本的に違うところ，かなあ．<br />
これを回避するには
<pre style="background:#000;color:#f8f8f8">
Prelude> let r = 3
</pre>
とやれば良く，以降もたまに使いますが，基本的には以下でやる通り，<br />
ソースファイルを作って読み込んでもらって interacitve にいろいろやっていく<br />
のがとりあえずは吉です． 
</p>
<p>
とりあえずこのあたりは一旦置いといて．変数定義はソースファイルから読み込んでやりましょう．<br />
<code>Varfun.hs</code> をつくる（Haskell の場合拡張子は .hs が普通みたい）．
<pre style="background:#000;color:#f8f8f8">
r <span style="color:#e28964">=</span> <span style="color:#3387cc">5.0</span>
</pre>
Haskell さん，こう見えて whitespace sensitive なので行頭にスペースは入れないように．<br />
なお <code>=</code> 前後のスペースはどうでも良い模様．<br />
で，これを GHCi から読み込むときには<code>:cd</code>で cd して <code>:load</code> か <code>:l</code>で読み込む．
<pre style="background:#000;color:#f8f8f8">
Prelude> :load Varfun.hs 
[1 of 1] Compiling Main             ( Varfun.hs, interpreted )
Ok, modules loaded: Main.
*Main> r
5.0
</pre>
という感じですね．Tab 補完も効く模様．<br />
ghci を起動するときに引数として渡してやってもよいようだ．
<pre style="background:#000;color:#f8f8f8">
$ ghci Varfun.hs
GHCi, version 7.6.2: <span style="color:#e18964;text-decoration:underline">http://www.haskell.org/ghc/</span>  :? for help
Loading package ghc-prim ... linking ... done.
Loading package integer-gmp ... linking ... done.
Loading package base ... linking ... done.
[1 of 1] Compiling Main             ( varfun.hs, interpreted )
Ok, modules loaded: Main.
*Main> 
</pre>
変数名は小文字の英字で始めねばならず，残りは文字，数字，underscore (_), tick (') を使用できます．<br />
他の言語なら myfoo みたいな付け方をする場合には foo' とか使うのもいいかもしれません．<br />
そして，本来なら Haskell さんは静的格付け言語なのですが，型推論をやってくれるので今は無指定で大丈夫です．
</p>
<p>
もうちょっと書き足してみよう．エディタから<code>Varfun.hs</code>を編集
<pre style="background:#000;color:#f8f8f8">
r <span style="color:#e28964">=</span> <span style="color:#3387cc">5</span>
area <span style="color:#e28964">=</span> <span style="color:#dad085">pi</span>*r^<span style="color:#3387cc">2</span>
</pre>
で ghci から <code>:reload</code> か <code>:r</code>で読み込み（引数は不要）．<br />
こんなかんじになるはず
<pre style="background:#000;color:#f8f8f8">
*Main> :r
[1 of 1] Compiling Main             ( Varfun.hs, interpreted )
Ok, modules loaded: Main.
*Main> area
78.53981633974483
*Main> area / r^2
3.141592653589793
*Main> 
</pre>
めでたし． <br />
こうしてファイルから ghci に読み込むのじゃなくて， ghc でコンパイルすることも（もちろん）できます．<br />
そのへんもまたそのうちに．そのうちにっていうか
<pre style="background:#000;color:#f8f8f8">
$ ghc foo.hs
</pre>
でいいんですけどね．
</p>

<h3>Comments</h3>
<p>Haskell のコメントは <code>--</code> に続けて書く(LaTeX の <code>%</code>, python の <code>#</code> 相当)．
<pre style="background:#000;color:#f8f8f8">
x <span style="color:#e28964">=</span> <span style="color:#3387cc">5</span>     <span style="color:#aeaeae;font-style:italic">-- The variable x is 5.</span>
y <span style="color:#e28964">=</span> <span style="color:#3387cc">6</span>     <span style="color:#aeaeae;font-style:italic">-- The variable y is 6.</span>
<span style="color:#aeaeae;font-style:italic">-- z = 7</span>
</pre>
行の最後まで続かないの，あるいは複数行に渡るのは<code>{- comments -}</code>.
<pre style="background:#000;color:#f8f8f8"> x <span style="color:#e28964">=</span> <span style="color:#aeaeae;font-style:italic">{- Don't do this just because you can. -}</span> <span style="color:#3387cc">5</span> 
</pre>
</p>

<h3>Variables in imperative languages</h3>
<p>
大事なこと言います．
<blockquote>
Haskell では，変数の値は変化しない．
</blockquote>
もう一度言います．
<blockquote><b>Variables do not vary.</b></blockquote>
大事なことだから三回目
<blockquote>
<pre><big><b>
＿人人人人人人人人人人人人＿
＞　変数の値は変化しない　＜
￣Y^Y^Y^Y^Y^Y^Y^Y^Y^Y^Y￣
</big></b></pre>
</blockquote>
<b>な，なんだってーーーーーー！！</b><br /><br />
</p>
<p>
<code>DoubleDeclarations.hs</code>
<pre style="background:#000;color:#f8f8f8">
a <span style="color:#e28964">=</span> <span style="color:#3387cc">3</span>
a <span style="color:#e28964">=</span> <span style="color:#3387cc">5</span>
</pre>
で
<pre style="background:#000;color:#f8f8f8">
Prelude> :l DoubleDeclarations.hs 
[1 of 1] Compiling Main             ( DoubleDeclarations.hs, interpreted )

DoubleDeclarations.hs:2:1:
    Multiple declarations of `a'
    Declared at: DoubleDeclarations.hs:1:1
                 DoubleDeclarations.hs:2:1
Failed, modules loaded: none. 
</pre>
<i><code>Multiple declarations of `a'.</code></i><br />
<code> a </code> が2回定義されてるやん，おかしいやん，って言われてしまいました．<br />
<small>ちなみにこのように ghci のエラー表示は非常に親切かつ賢くて，丁寧に読むとかなり色々わかります，</small> <br />
これ，命令型言語なら， 1行目で a っていう ''箱'' に 3 が入り， 2行目で 5 になる，と読むところですが，<br />
我らが純粋関数型言語では，そうはならないわけです．数学で a = 3 って書いた時みたい．<br />
こんなのも：
<code> foo.hs </code> (ファイル名面倒になった)
<pre style="background:#000;color:#f8f8f8">
a <span style="color:#e28964">=</span> <span style="color:#3387cc">3</span>
a <span style="color:#e28964">=</span> a<span style="color:#e28964">+</span><span style="color:#3387cc">1</span>
</pre>
（これが動かないだと…!!）<br />
これは a の increment ではなく， a の再帰定義とみなされます．<br />
</p>
<p> 
これで直ちに嬉しいことの一つが，変数定義の順番を気にしなくて良いこと．
<pre style="background:#000;color:#f8f8f8">
y <span style="color:#e28964">=</span> x*<span style="color:#3387cc">2</span>
x <span style="color:#e28964">=</span> <span style="color:#3387cc">3</span>
</pre>
と
<pre style="background:#000;color:#f8f8f8">
x <span style="color:#e28964">=</span> <span style="color:#3387cc">3</span>
y <span style="color:#e28964">=</span> x*<span style="color:#3387cc">2</span>
</pre>
は同じ．もちろん y を実際に使うときには x の値が必要になりますが，<br />
そうして実際の特定の数値が必要になるまでは，べつに重要ではないというわけです．
</p>
<p>
でもそれどうするんですか，<code> for </code>文 loop とかどうすればいいんですか．<br />
→わくわくですよね．とにかく，ほんとにこれでうまく行くらしい． Haskell かっこいい．<br />
<small>実は，僕が Haskell をもうちょっとやろうと思った決定的な瞬間がこのあたりだったりします．<br />
すごくかっこよくて，すごく気持ちよさそう．もっと知りたいな，と思いました．それでいま勉強中．</small><br />
en.wikibooks から引用：
<blockquote><i>
By now, you probably look very incredulous and wonder how you can actually do anything at all in Haskell where variables don't change. But trust us; as we hope to show you in the rest of this book, you can write every program under the sun without ever changing a single variable!  In fact, variables that don't change make life so much easier because it makes programs much more predictable. It's a key feature of purely functional programming, not a bug.
</i></blockquote>
</p>
<h3> Functions </h3>
<p>
複数の円の面積を求めたい場合，
<pre style="background:#000;color:#f8f8f8">
<span style="color:#aeaeae;font-style:italic">-- twoareas.hs</span>
r <span style="color:#e28964">=</span> <span style="color:#3387cc">5</span>
area <span style="color:#e28964">=</span> <span style="color:#dad085">pi</span>*r^<span style="color:#3387cc">2</span>
r2 <span style="color:#e28964">=</span> <span style="color:#3387cc">3</span>
area2 <span style="color:#e28964">=</span> <span style="color:#dad085">pi</span>*r2^<span style="color:#3387cc">2</span>
</pre>
…なんてやるのはあまりにひどい．ここで function の出番です．<p />
<p>
function は argument value (or parameter) をとって，結果の値を与えるもの．<br />
数学の函数と (Haskell でいう関数は！）一緒です．<br />
書き方はシンプル，variable 定義するのと同じノリで，左辺に argument を書いておく．
<pre style="background:#000;color:#f8f8f8">
area r <span style="color:#e28964">=</span> <span style="color:#dad085">pi</span> * r^<span style="color:#3387cc">2</span> <span style="color:#aeaeae;font-style:italic">-- 数式っぽく書くなら A(r) = \pi * r^2</span>
</pre>
関数名，space あけて argument(s) で括弧は使わない．<br />
特別な syntax はない． r = 5 って定義したのと同じノリで，この書き方で定義する．<br />
</p>
<p>
さてではこれを call してみよう．とりあえずは ghci で読み込んで
<pre style="background:#000;color:#f8f8f8">
*Main> area 3
28.274333882308138
*Main> area 5
78.53981633974483
*Main> :t area
area :: Floating a => a -> a
</pre>
<code> :t </code> のところ，まだ出てきてませんが type のことをやれば意味がわかるので少しお待ちを．
</p>
<p>
関数では括弧は使いませんが， expressions （値を与えるあらゆる code) を纏めて一緒に評価させるときに使われます．<br />
たとえば
<pre style="background:#000;color:#f8f8f8">
area (<span style="color:#3387cc">5</span><span style="color:#e28964">+</span><span style="color:#3387cc">3</span>)
</pre>
は最初に <code> 5+3 </code> （もちろん 8 ）を計算して，その <code> area </code> を計算します．一方
<pre style="background:#000;color:#f8f8f8">
area <span style="color:#3387cc">5</span> <span style="color:#e28964">+</span> <span style="color:#3387cc">3</span>
</pre>
ではまず <code> area 5 </code> を計算して，それに <code> 3 </code> を足すことになります．<br />
これは掛け算が足し算より順位が高いのとおなじように， function call が先に行われるということです．<br />
では
<pre style="background:#000;color:#f8f8f8">
area <span style="color:#3387cc">5</span> * <span style="color:#3387cc">3</span>
area <span style="color:#3387cc">1</span> ^ <span style="color:#3387cc">3</span>
</pre>
はそれぞれどうなるでしょう．（演習課題？）
</p>
<p>
せっかくだから，もうちょっと関数を書いてみよう．
<pre style="background:#000;color:#f8f8f8">
double x <span style="color:#e28964">=</span> <span style="color:#3387cc">2</span> * x
quadruple x <span style="color:#e28964">=</span> double(double x)
square x <span style="color:#e28964">=</span> x * x
half x <span style="color:#e28964">=</span> x <span style="color:#e28964">/</span> <span style="color:#3387cc">2</span>
</pre> 

</p> 
<h4> Evaluation </h4>
<p>
GHCi に expression を打ち込んだ時に何が起こるのか． <br />
Enter 押したら ghci は打ち込んだ expression を 評価 --evaluate-- します．<br />
これはつまり， 関数を定義で置き換え，結果を計算して，最後に値がひとつだけ残るまでそれをやる，ということ．<br />
さっきの <code> area 5 </code> でやってみましょうか．
<pre style="background:#000;color:#f8f8f8">
    area <span style="color:#3387cc">5</span>
<span style="color:#e28964">=></span>   <span style="color:#aeaeae;font-style:italic">{- 定義の area r = を 右辺の pi * r^2 で置き換え-}</span>
    <span style="color:#dad085">pi</span> * <span style="color:#3387cc">5</span>^<span style="color:#3387cc">2</span>
<span style="color:#e28964">=></span> <span style="color:#aeaeae;font-style:italic">{- pi を数値に置き換え-}</span>
    <span style="color:#3387cc">3.141592653589793</span> * <span style="color:#3387cc">5</span>^<span style="color:#3387cc">2</span>
<span style="color:#e28964">=></span> <span style="color:#aeaeae;font-style:italic">{- 指数(^)を適用 -}</span>
    <span style="color:#3387cc">3.141592653589793</span> * <span style="color:#3387cc">25</span>
<span style="color:#e28964">=></span> <span style="color:#aeaeae;font-style:italic">{- 掛け算 -}</span>
    <span style="color:#3387cc">78.53981633974483</span>
</pre>
あ，別に <code> => </code> は Haskell さん的なアレじゃないよ．
</p>
<p>
練習問題．
<ul>
	<li> 少し前の <code> quadruple 5 </code> は ghci さんにどう評価されるか．再掲すると
<pre style="background:#000;color:#f8f8f8">
double x <span style="color:#e28964">=</span> <span style="color:#3387cc">2</span> * x
quadruple x  <span style="color:#e28964">=</span> double(double x)
</pre>
	</li>
	<li>引数の半分から 12 を引く関数書いてみよう．</li>
</ul>
</p>
<h4> Multiple parameters </h4>
<p>
もちろん引数は一つとは限らないよー．縦と横与えられて長方形の面積：
<pre style="background:#000;color:#f8f8f8">
areaRect l w <span style="color:#e28964">=</span> l * w
</pre>
で
<pre style="background:#000;color:#f8f8f8">
*Main> areaRect 5 10
50
</pre>
直角三角形の面積求めるぜ
<pre style="background:#000;color:#f8f8f8">
areaRightTriangle b h <span style="color:#e28964">=</span> (b * h) <span style="color:#e28964">/</span><span style="color:#3387cc">2</span>
</pre>
使うときはこんなかんじに引数同士をスペースで区切る．<br />
だから括弧使わないと誤解が生じることもあるわけですねー．
<pre style="background:#000;color:#f8f8f8">
quadruple x <span style="color:#e28964">=</span> double double x
</pre>
と，書くとします．実は関数も他の関数の引数になれちゃうので誤解が起きる．<br />
関数を関数に投げる話はまた後でするとして，とりあえずちゃんと誤解を解くために
<pre style="background:#000;color:#f8f8f8">
quadruple x <span style="color:#e28964">=</span> double (double x)
</pre>
としませう．<br />
一応確認しとくと順番は書いてあるままです．
<pre style="background:#000;color:#f8f8f8">
<span style="color:#dad085">subtract</span> x y <span style="color:#e28964">=</span> x <span style="color:#e28964">-</span> y
</pre>
なら<code> subtract 10 5 </code> は <code> 5 </code>, <code> subtract 5 10 </code> は <code> -5.</code>
なおいままで何の気無しに使ってた <code>+</code> とかも関数で，<code> (+) </code> と書くと本来の関数としての syntax で使えます．
Couldn't load grammar file: Plain Text\

演習．
<ul>
	<li>直方体の体積出す関数書いてみよう．</li>
	<li>Giza のピラミッドって大体どのくらいの数の石でできてるだろう？ GHCi さんの助けを借りて計算してみよう．</li>
</ul>
</p>
<p>
関数使って関数作るのももちろんできるよ<br />
長方形と正方形の面積求めるもの
<pre style="background:#000;color:#f8f8f8">
areaRect l w <span style="color:#e28964">=</span> l * w
areaSquare s <span style="color:#e28964">=</span> areaRect s s
</pre>
こういうのできるの，後々わかってくるけど超便利．<br />
演習．
<ul>
<li> 円柱の体積求める関数書いてみよう．</li>
</ul>
</p>
<h3> Local definitions </h3>
<h4> <code>where</code> clauses </h4>
<p>
その関数の中でしか使わへんようなやつをいちいちきちんと定義するのもアレなので．<br />
Heron の公式 ($ A = \sqrt{s (s-a) (s-b) (s-c)} $ where $ s = (a+b+c)/2 $) 
<pre style="background:#000;color:#f8f8f8">
heron a b c <span style="color:#e28964">=</span> <span style="color:#dad085">sqrt</span> ( s*(s<span style="color:#e28964">-</span>a)*(s<span style="color:#e28964">-</span>b)*(s<span style="color:#e28964">-</span>c) )
    <span style="color:#e28964">where</span> 
    s <span style="color:#e28964">=</span> (a<span style="color:#e28964">+</span>b<span style="color:#e28964">+</span>c) <span style="color:#e28964">/</span> <span style="color:#3387cc">2</span>
</pre>
<code>where</code> と local definitions はスペース4つでインデントして区別されます．<br />
このへん python みたいに whitespace sensitive なわけですねー．<br />
そしてこれを，
<pre style="background:#000;color:#f8f8f8">
heron a b c <span style="color:#e28964">=</span> <span style="color:#dad085">sqrt</span> ( s*(s<span style="color:#e28964">-</span>a)*(s<span style="color:#e28964">-</span>b)*(s<span style="color:#e28964">-</span>c) ) <span style="color:#aeaeae;font-style:italic">-- s はここでは定義されてない</span>
s <span style="color:#e28964">=</span> (a<span style="color:#e28964">+</span>b<span style="color:#e28964">+</span>c) <span style="color:#e28964">/</span> <span style="color:#3387cc">2</span>  <span style="color:#aeaeae;font-style:italic">-- ここでは a, b, c が定義されてない</span>
</pre>
と書くと，<code> s = (a+b+c)/2 </code> のところは <code> heron </code> の右辺の定義の一部としては解釈されないので，<br />
所定の結果は得られません．
</p>
<p>他の例．
<pre style="background:#000;color:#f8f8f8">
areaTriangleTrig a b c <span style="color:#e28964">=</span> c * height <span style="color:#e28964">/</span> <span style="color:#3387cc">2</span> <span style="color:#aeaeae;font-style:italic">--三角関数で</span>
    <span style="color:#e28964">where</span>
    cosa <span style="color:#e28964">=</span> (b^<span style="color:#3387cc">2</span> <span style="color:#e28964">+</span> c^<span style="color:#3387cc">2</span> <span style="color:#e28964">-</span> a^<span style="color:#3387cc">2</span>) <span style="color:#e28964">/</span> (<span style="color:#3387cc">2</span>*b*c) <span style="color:#aeaeae;font-style:italic">--余弦定理</span>
    sina <span style="color:#e28964">=</span> <span style="color:#dad085">sqrt</span>(<span style="color:#3387cc">1</span> <span style="color:#e28964">-</span> cosa^<span style="color:#3387cc">2</span>)
    height <span style="color:#e28964">=</span> b * sina
areaTriangleHeron a b c <span style="color:#e28964">=</span> result <span style="color:#aeaeae;font-style:italic">--ヘロンの公式から</span>
    <span style="color:#e28964">where</span>
    result <span style="color:#e28964">=</span> <span style="color:#dad085">sqrt</span>(s*(s<span style="color:#e28964">-</span>a)*(s<span style="color:#e28964">-</span>b)*(s<span style="color:#e28964">-</span>c))
    s <span style="color:#e28964">=</span> (a<span style="color:#e28964">+</span>b<span style="color:#e28964">+</span>c) <span style="color:#e28964">/</span> <span style="color:#3387cc">2</span>
</pre>
</p>
<h4> Scope </h4>
<p>
上の例で <code> a </code> とか <code> b </code> とか <code> c </code> とかたくさん出てきたけど，大丈夫なんか．<br />
これはありがたいことに思ったとおりに動く：(<code>let</code> のことは一旦おいといて．)
<pre style="background:#000;color:#f8f8f8">
Prelude> let r = 0
Prelude> let area r = pi * r^2
Prelude> area 5
</pre>
最初に <code>r = 0</code> といってるから <code>area r = pi * r^2</code> で問答無用に 0や! とはなりません．<br />
要するに 2つの<code> r </code> は別のものを指してるというわけ．<br />
詳しくはここでは省くけど， scope っていう（他の言語にもあるよね）仕組みで上手くいくようになってるかんじです．<br />
つまり，<code>=</code> で結ぶと，以降その定義の scope に照らして適切である範囲で右辺と置き換えられる，みたいな．<br />
感じ．詳細がなくてすっきりしないけど．
</p>
<h2> Truth Values</h2>
<h3> Equality and other comparisons / Boolean Values  </h3>
<p>
アレだ，数学で <code>=</code> って書いてもどっちかいうと proposition としてのそれがあるようなかんじで．
2つの値の比較には <code>==</code> を使う．
<pre style="background:#000;color:#f8f8f8">
Prelude> 2 + 3 == 5
True
</pre>
あるいは <code>False</code> が帰ってくる．大小比較は <code> >, <, <=, >=</code> で．
<pre style="background:#000;color:#f8f8f8">
Main*> area 5 &lt; 50
</pre>
みたいな書き方ももちろん出来ます．<br />
帰ってくる値は Boolean values, ないし truth values.
</p>

<h3> An introduction to types </h3>
<p>
Type の話だ！楽しみにしましょう！わーい！<br />
Truth values が values というてるけど，これはマジでそういうことで， 数値と同じ意味で値を持ってる．<br />
例えば
<pre style="background:#000;color:#f8f8f8">
Prelude> True == True
True
Prelude> True == False
False
</pre>
ってな感じ．では「2 と True は等しいでしょうか？」
<pre style="background:#000;color:#f8f8f8">
Prelude> 2 == True

&lt;interactive>:3:1:
    No instance for (Num Bool) arising from the literal `2'
    Possible fix: add an instance declaration for (Num Bool)
    In the first argument of `(==)', namely `2'
    In the expression: 2 == True
    In an equation for `it': it = 2 == True
</pre>
そんな比較はできません．<small>上で ghci さんが何を言ってるのかは後ほど読めるようになる．</small><br />
左辺は数 (type としては <code>Num</code>), 右辺は Boolean value (<code>Bool</code>)<br />
型 (type) が違うので，比較のしようがないのです．<br />
これまでは ghci が勝手に解釈してくれていましたが，自分で型を指定することもでき，<br />
Haskell のこの型システムは，ちゃんと意味が通るように物事を動かす上で非常に強力です．<br />
超大事で格好いいので次の章はこの型の話．その前に今の話を片付けてしまいましょう． 
</p>
<h3> Infix operators </h3>
<p>
さっきの 2 と True を調べた時，
<pre style="background:#000;color:#f8f8f8">
In the first argument of `(==)', namely `2'
</pre>
さて ghc さんは 2 を first argument of (==) と呼んでるわけやけれども，この (==) も普通の函数．<br />
ただ syntax 的にちょっと違って， Haskell ではこういう，<br />
名前が英数以外の記号だけでできてる 2 変数関数 は中置できることになってるらしい．<br />
infix operators, と呼ぶそうな．普通の関数みたいに使うときは ( ) でくくる．
<pre style="background:#000;color:#f8f8f8">
Prelude (==) (4 + 9) 13
True
</pre>
逆にさっきの <code>areaRect</code> みたいな関数を中置したい時は ` `  でくくって
<pre style="background:#000;color:#f8f8f8">
<span style="color:#3387cc">2</span> <span style="color:#e28964">`areaRect`</span> <span style="color:#3387cc">5</span>
</pre>
と書ける．これではあんまり嬉しさもないけど，<code>3 `mod` 2</code> みたいな書き方は素敵そう．<br />
というわけで <code>==</code> も <code>+</code> も <code> >= </code> もなんでもかんでも関数です．
</p>
<h3> Boolean operations </h3>
and は <code>(&&)</code>, or は <code>(||)</code>, <code>not</code> で論理否定．<br />
いずれもさっきの infix operator な記法に従います．
<pre style="background:#000;color:#f8f8f8">
Prelude> (3 &lt; 8) &amp;&amp; (False == False)
True
Prelude> (&amp;&amp;) (3 &lt; 8) (False == False)
True
Prelude> not (5*2 == 10)
False
</pre>
みたいな感じ．なお， not equal to については <code>/=</code> (\neq に形を似せたという噂？) とも書ける．あえて書くなら<br />
<pre style="background:#000;color:#f8f8f8">
x <span style="color:#e28964">/=</span> y <span style="color:#e28964">=</span> <span style="color:#dad085">not</span> (x <span style="color:#e28964">==</span> y)
</pre>
というかんじ（この書き方で完全に正しい）．
<h3> Guards </h3>
<p>
絶対値を吐く関数を書いてみましょう．Haskell に <code>abs</code> 関数があるので自分で書かなくてもいいんですが．<br />
書きたいのは，数式で書くと
<pre>
|x| =  x    if x >= 0
      -x    if x <  0
</pre>
ってこと．<br />
</p>
<p>
さて Haskell で書くでーーーー！<br />
<pre style="background:#000;color:#f8f8f8">
myabs x
      <span style="color:#e28964">|</span>  x <span style="color:#e28964">&lt;</span> <span style="color:#3387cc">0</span>      <span style="color:#e28964">=</span> <span style="color:#3387cc">0</span> <span style="color:#e28964">-</span> x
      <span style="color:#e28964">|</span>  <span style="color:#dad085">otherwise</span>  <span style="color:#e28964">=</span> x
</pre>
大変読みやすくまとまっております．
<ul>
<li>まず普通に書き始めて</li>
<li><code>=</code> 書かずに改行，インデントを置いて（これは文法上必要）場合分けを書く．
<ul><li>場合分けは <code>|</code> に続けて，Bool 値を返す expression, <code>=</code> とその場合の右辺の順．<li>
<li>それぞれが guard と呼ばれるらしいぜ！</li>
<li>otherwise は otherwise. 別になくても構わない．さっきので言えば <code>x<=0</code> で書いてもよかった．<br />
けどどれも True にならなかったら runtime error になるから使っといたほうがいい．</ul></li>
</ul>
</p>
<p>
注意点．
<ul>
<li> <code>otherwise</code> 格好いいけど実は
<pre style="background:#000;color:#f8f8f8">
<span style="color:#dad085">otherwise</span> <span style="color:#e28964">=</span> <span style="color:#cf6a4c">True</span>
</pre>
って定義されてるだけらしい．賢いな．でもだから最後に置かなあかんよ．</li>
<li>
わざわざ <code>0 - x</code> って書いたけど，この場合は関数としてやなくてあくまで記法上の簡略化として 
<code> -x </code> とだけ書いてもよかった．ただ <code> 3 - -5</code> みたいな書き方は括弧なしでは通らないので気をつけよう．
</li>
</ul>
</p>
<h4> <code>where</code> and Guards </h4>
<p>
<code>where</code> と guard の組み合わせは使いやすい．<br />
二次方程式 ax^2 + bx + c = 0 の解の個数
<pre style="background:#000;color:#f8f8f8">
numOfSolutions a b c 
    <span style="color:#e28964">|</span> disc <span style="color:#e28964">></span> <span style="color:#3387cc">0</span>  <span style="color:#e28964">=</span> <span style="color:#3387cc">2</span>
    <span style="color:#e28964">|</span> disc <span style="color:#e28964">==</span> <span style="color:#3387cc">0</span> <span style="color:#e28964">=</span> <span style="color:#3387cc">1</span>
    <span style="color:#e28964">|</span> <span style="color:#dad085">otherwise</span> <span style="color:#e28964">=</span> <span style="color:#3387cc">0</span>
        <span style="color:#e28964">where</span> 
        disc <span style="color:#e28964">=</span> b^<span style="color:#3387cc">2</span> <span style="color:#e28964">-</span> <span style="color:#3387cc">4</span>*a*c
</pre>
ここで <code>where</code> の scope は guard 全部の下に入ってるってことらしい．
</p>

<h2> Type Basics!!!!!!!!!!! </h2>
ｳｯﾋｮｵｵｵｵｵｵｵｵｵｵｵｵｵｵｵｵｵｵ type ﾀﾞｱｱｱｱｱｱｱｱｱ<br />
<p>
…コホン．
<ul>
<li>Haskell での型は大文字から始まる．String が string. 自分で型作るのもできるぜ </li>
<li>例えば電話番号とかは，もちろん普通の数として扱ってもいいけど，
<code>TelephoneNumber</code> みたいな型として見たほうが情報をたくさん得られたり，要らん混乱を弾いたりできそう．</li>
<li> ghci で <code>:t</code> ないし <code>:type</code> コマンド使ったらどの type か教えてくれるぜ！</li>
</ul>
</p>
<p>
というわけで :t やってみるぞー！！<br />
</p>
<p>
いろんな値
<pre style="background:#000;color:#f8f8f8">
Prelude> :t True
True :: Bool
Prelude> :t (3 &lt; 2)
(3 &lt; 2) :: Bool
Prelude> :t 'a'
'a' :: Char
Prelude> :t "a"
"a" :: [Char]
Prelude> :t 'ab'

&lt;interactive>:1:1:
    Syntax error on 'ab'
    Perhaps you intended to use -XTemplateHaskell
Prelude> :t "ab"
"ab" :: [Char]
Prelude> :t 31
31 :: Num a => a
Prelude> :t 3.2
3.2 :: Fractional a => a
Prelude> :t (2/3)
(2/3) :: Fractional a => a
</pre>
<code> Fractional a => a</code>とかはあとで．a は Fractional やでっていう束縛みたいなもの．<br />
<code>String</code> は <code>[Char]</code> のこと（どっちでも書いてもいい）で，<br />
<code>[Char]</code> は <code>Char</code> の list のこと．<br />
</p>
<p>
関数とか．引数が複数あるときは<code>甲 :: (引数1)->(引数2)->..->(引数n)->(返り値）</code> と表す．
<pre style="background:#000;color:#f8f8f8">
Prelude> :t not
not :: Bool -> Bool
Prelude> :t (+)
(+) :: Num a => a -> a -> a
Prelude> :t (/)
(/) :: Fractional a => a -> a -> a
Prelude> :t (^)
(^) :: (Integral b, Num a) => a -> b -> a
Prelude> :t (**)
(**) :: Floating a => a -> a -> a
Prelude> :t ^ --ちなみにこれは
&lt;interactive>:1:1: parse error on input `^'
Prelude> let areaRect x y = x * y
Prelude> :t areaRect -- 自分では型指定してないけど推論してくれてる
areaRect :: Num a => a -> a -> a
</pre>
アレやで， <code>1 + </code> とかも関数やで
<pre style="background:#000;color:#f8f8f8">
Prelude> :t (3&lt;)
(3&lt;) :: (Num a, Ord a) => a -> Bool
Prelude> :t (1+)
(1+) :: Num a => a -> a
</pre>
<p>
この <code>::</code> は type signature と言われ，自分で型宣言するときもこうすればよい．<br />
<pre style="background:#000;color:#f8f8f8">
<span style="color:#89bdff">a</span> <span style="color:#e28964">::</span> <span style="color:#9b859d">Integer</span>
a <span style="color:#e28964">=</span> <span style="color:#3387cc">3</span>
<span style="color:#89bdff">mynot</span> <span style="color:#e28964">::</span> <span style="color:#9b859d">Bool</span> <span style="color:#e28964">-></span> <span style="color:#9b859d">Bool</span>
mynot arg
    <span style="color:#e28964">|</span> arg        <span style="color:#e28964">=</span> <span style="color:#cf6a4c">False</span>
    <span style="color:#e28964">|</span> <span style="color:#dad085">otherwise</span>  <span style="color:#e28964">=</span> <span style="color:#cf6a4c">True</span>
</pre>
的な．複数同じ型を持ってる場合は <code>a,b :: (type)</code> ってまとめてかけるぜ．
</p>
<p>
具体例を考えてみようか．<code>chr</code> と <code>ord</code>, ASCII な感じの番号と文字の相互変換．<br />
これを使うには <code>Data.Char</code> を import する． ghci からなら
<pre style="background:#000;color:#f8f8f8">
Prelude> :m Data.Char 
</pre>
(または <code>:module</code>) で import して
<pre style="background:#000;color:#f8f8f8">
Prelude Data.Char> chr 97
'a'
Prelude Data.Char> chr 96
'`'
Prelude Data.Char> ord 'm'
109
</pre>
.hs 書くなら
<pre style="background:#000;color:#f8f8f8">
<span style="color:#e28964">import</span> <span style="color:#9b859d">Data.Char</span>
</pre>
python みたいに <code>Data.Char.chr(97)</code> とはしない．これの型は
<pre style="background:#000;color:#f8f8f8">
chr :: Int -> Char
ord :: Char -> Int
</pre>
</p>
<p>
<code>xor</code> とか書いてみるか．
<pre style="background:#000;color:#f8f8f8">
xor p q <span style="color:#e28964">=</span> (p <span style="color:#e28964">||</span> q) &amp;&amp; <span style="color:#dad085">not</span> (p &amp;&amp; q)
</pre>
Bool と Bool で Bool 返すので
<pre style="background:#000;color:#f8f8f8">
Prelude> :l xor.hs 
[1 of 1] Compiling Main             ( xor.hs, interpreted )
Ok, modules loaded: Main.
*Main> :t xor
xor :: Bool -> Bool -> Bool
*Main> 
</pre>
</p>
<p>
もうちょっと現実的っぽい例を．GUI で使うような，ウィンドウ開くやつ．<br />
ちょっと簡略化してるけどイメージ的には
<pre style="background:#000;color:#f8f8f8">
<span style="color:#89bdff">openWindow</span> <span style="color:#e28964">::</span> <span style="color:#99cf50">WindowTitle</span> <span style="color:#e28964">-></span> <span style="color:#99cf50">WindowSize</span> <span style="color:#e28964">-></span> <span style="color:#99cf50">Window</span>
</pre>
ね，分かりやすそうやん．とりあえずこれからも <code>:t</code> は常に使って行きましょう．
</p>
<p>
練習問題．それぞれ型はどうかけるでしょう．
<ol>
<li>関数 <code>negate</code>, Int を受け取ってその符号を逆にしたのを返す．<code>negate 3 = -3, negate -3 = 3</code> など．</li>
<li>関数 <code>(||)</code>. </li>
<li><code>monthLength</code>. うるう年かどうかの Bool と月を表す Int からその月の日の数を返す．</li>
<li><code>f x y = not x && y</code></li>
<li><code>g x = (2*x - 1)ˆ2</code>. 数は Int.</li>
</ol>
</p>

<h3> Type Inference</h3>
<p>
type signature を僕らが書かなくても ghci とか ghc はわかってくれる，のは，<br />
type inference, 型推論ってのをやってくれるから．流れはこんな感じ．
<pre style="background:#000;color:#f8f8f8">
isL c <span style="color:#e28964">=</span> c <span style="color:#e28964">==</span> <span style="color:#65b042">'l'</span>
</pre>
type signature 無しに書いてみる．ちゃんとこれでも
<pre style="background:#000;color:#f8f8f8">
:t isL
isL :: Char -> Bool
</pre>
とわかってくれてるわけ．<br />
<ul>
<li>まず 'l' は Char.</li>
<li>となるとそれと <code>(==)</code> で比べられるためには c は Char じゃないとね</li>
<li>最後に帰ってくるのは Bool だよね</li>
</ul>
って感じですね．<br />
とはいえコードの読みやすさとか，バグ取りのこととか考えると type signature は積極的にしていこう．<br />
たとえば typo とかしても， type signature をしといたら弾けることも多いけど，<br />
signature なかったらそのまま変な型推論して妙なところで error でるかもしれないよね．<br />
それに関数名と type signature 見たらだいたい何するかわかったりもするし．<br />
このへんの事のおかげで，Haskell では「コンパイルは通ったけど動かしてみたら変な感じ」ってことは少なくて，<br />
コンパイルの段階で「なんか変ﾀﾞﾖｰ」ってなって，コンパイルさえ通ればまあちゃんと動くぜって感じみたい． すごい．
</p>
<h2> Lists and tuples </h2>
list と tuple のお話．
<h3> Lists </h3>
<p>
list の書き方：
<pre style="background:#000;color:#f8f8f8">
numbers <span style="color:#e28964">=</span> [<span style="color:#3387cc">1</span>,<span style="color:#3387cc">2</span>,<span style="color:#3387cc">3</span>,<span style="color:#3387cc">86</span>]
strings <span style="color:#e28964">=</span> [<span style="color:#65b042">"here"</span>, <span style="color:#65b042">"are"</span>, <span style="color:#65b042">"some"</span>, <span style="color:#65b042">"strings"</span>]
bools <span style="color:#e28964">=</span> [<span style="color:#cf6a4c">True</span>, <span style="color:#cf6a4c">False</span>, <span style="color:#cf6a4c">True</span>, <span style="color:#cf6a4c">False</span>]
</pre>
<ul>
<li>同じ type のものだけを集められます（異なる type をまとめようとすると type error:
<pre style="background:#000;color:#f8f8f8">
Prelude> let thisdoesntwork = [2, 'a']

&lt;interactive>:5:23:
    No instance for (Num Char) arising from the literal `2'
    Possible fix: add an instance declaration for (Num Char)
    In the expression: 2
    In the expression: [2, 'a']
    In an equation for `thisdoesntwork': thisdoesntwork = [2, 'a']
</pre></li>
<li> <code>(足すもの):(list)</code>という記法で要素を足した list を手に入れることができます(このことを cons (<i>verb</i>) というらしい)．この時の evaluation は右から左に行われ，好きなだけつなげて行けます．
<pre style="background:#000;color:#f8f8f8">
Prelude> let numbers = [1,2,3,1,4]
Prelude> 1:numbers
[1,1,2,3,1,4]
Prelude> 1:0:4:numbers
[1,0,4,1,2,3,1,4]
Prelude> numbers:numbers

&lt;interactive>:5:9:
    Couldn't match type `Integer' with `[Integer]'
    Expected type: [[Integer]]
      Actual type: [Integer]
    In the second argument of `(:)', namely `numbers'
    In the expression: numbers : numbers
    In an equation for `it': it = numbers : numbers
</pre>
っていう感じ．
<ul>
<li>ほんま言うと <code>[1,2,3]</code> っていうの自体も <code>1:2:3:[]</code> の syntax sugar. 最後の <code>[]</code> 忘れないように．</li>
<li><code>(:)</code> も例によって関数．
<pre style="background:#000;color:#f8f8f8">
Prelude> :t (:)
(:) :: a -> [a] -> [a]
</pre>
<li>前言った通り String は Char の list なので，
<pre style="background:#000;color:#f8f8f8">
Prelude> 't':"here"
"there"
Prelude> "me" == ['m','e']
True
</pre>
</ul></li>
<li>あれ，それなら <code>[]</code> の type ってなんなんだろう．
<pre style="background:#000;color:#f8f8f8">
Prelude> :t []
[] :: [a]
</pre>
Haskell 「なんかわからんけどなんかのリストや」<br />
なるほど．</li>
<li>型さえ揃ってれば何でもいいので，（型が同じ） list の list も作れます．
<pre style="background:#000;color:#f8f8f8">
listOfLists <span style="color:#e28964">=</span> [ [<span style="color:#3387cc">1</span>,<span style="color:#3387cc">2</span>], [<span style="color:#3387cc">3</span>,<span style="color:#3387cc">4</span>], [<span style="color:#3387cc">5</span>,<span style="color:#3387cc">6</span>,<span style="color:#3387cc">7</span>]]
anotherList <span style="color:#e28964">=</span> <span style="color:#3387cc">[]</span><span style="color:#e28964">:</span>[<span style="color:#3387cc">1</span>]<span style="color:#e28964">:</span><span style="color:#3387cc">[]</span><span style="color:#e28964">:</span><span style="color:#3387cc">[]</span>
</pre>
でもこんなのはだめよ
<pre style="background:#000;color:#f8f8f8">
lol  <span style="color:#e28964">=</span> [ <span style="color:#3387cc">1</span>, [<span style="color:#3387cc">1</span>,<span style="color:#3387cc">2</span>]]
lol2 <span style="color:#e28964">=</span> [ [<span style="color:#65b042">'a'</span>], [<span style="color:#3387cc">2</span>] ]
</pre>
</ul> 
</p>
<p>
練習問題．はまあ省略でいいわ．
</p>
<h3> Tuples </h3>
<p>
Tuples の書き方：
<pre style="background:#000;color:#f8f8f8">
tuple1 <span style="color:#e28964">=</span> (<span style="color:#3387cc">1</span>,<span style="color:#3387cc">3.3</span>)
tuple2 <span style="color:#e28964">=</span> (<span style="color:#cf6a4c">True</span>, <span style="color:#3387cc">3</span>)
tuple3 <span style="color:#e28964">=</span> (<span style="color:#3387cc">4</span>, <span style="color:#3387cc">5</span>, <span style="color:#65b042">"Six"</span>, <span style="color:#cf6a4c">True</span>, <span style="color:#65b042">'b'</span>)
tuple4 <span style="color:#e28964">=</span> ((<span style="color:#3387cc">2</span>,<span style="color:#3387cc">3</span>), [<span style="color:#3387cc">2</span>,<span style="color:#3387cc">3</span>])
</pre>
Tuple は
<ul>
<li>要素の数は変更できない (immutable). <code>(:)</code> で cons することも従ってできない．
<ul><li>だから座標を表すのとかにいいかも．</li>
<li>要素の数 n に対して一般には n-tuple. 2 の時は pair, 3の時は triple ということが多い．一応それ以降は quadruples, quintuples と続く．tuple の名はここから．</ul>
</li>
<li>要素の型がそろってなくてもいい．
<ul><li>電話帳とかにいいかも．</li></ul></li>
</ul></p>
<p>
補足事項
<ul>
<li>関数のとる値とかがこれになるようにしとくと複数の値を返す相当だぜ</li>
<li>マスターいつもの
<pre style="background:#000;color:#f8f8f8">
Prelude> :t ('a', True)
('a', True) :: (Char, Bool)
Prelude> :t ()
() :: ()
</pre>
前者からわかるとおり，<code>('a', True)</code> と <code>(True, 'a')</code> は type が別になるので注意．
</li>
</ul>
</p>
<p>
というわけで tuple と list をそれぞれ入れ子にしたりできる．
<pre style="background:#000;color:#f8f8f8">
((<span style="color:#3387cc">2</span>,<span style="color:#3387cc">3</span>), <span style="color:#cf6a4c">True</span>)
((<span style="color:#3387cc">2</span>,<span style="color:#3387cc">3</span>), [<span style="color:#3387cc">2</span>,<span style="color:#3387cc">3</span>])
[(<span style="color:#3387cc">1</span>,<span style="color:#3387cc">2</span>), (<span style="color:#3387cc">3</span>,<span style="color:#3387cc">4</span>), (<span style="color:#3387cc">5</span>,<span style="color:#3387cc">6</span>)]
</pre>
たとえば
<pre style="background:#000;color:#f8f8f8">
[(<span style="color:#3387cc">1</span>,<span style="color:#3387cc">2</span>),(<span style="color:#3387cc">3</span>,<span style="color:#3387cc">4</span>,<span style="color:#3387cc">5</span>)]
</pre>
は通りませんで．
</p>
<h3> Retrieving Values </h3>
<p>
list とか tuple 作ったんだからそこから要素引き出したいぜ！<br />
っていう話なんやけど，ちょっと準備の必要な話でもあるので，まずは単純なやつだけ．<br />
いずれにしても割と気持ち悪いぜ！
<ul>
<li>list. <code>head</code> がリストの頭を，<code>tail</code> がそれ以降の部分を返す．正確にいうならそういう写像．<br />
これ，<code>(:)</code> で繋いだのの端っこを切ることでできている．
<pre style="background:#000;color:#f8f8f8">
Prelude> head [2,5,3,6]
2
Prelude> tail [2,5,3,6]
[5,3,6]
Prelude> head (2:5:3:6:[])
2
Prelude> head "there"
't'
Prelude> tail "there"
"here"
Prelude> tail "t"
""
Prelude> tail [1]
[]
Prelude> tail []
*** Exception: Prelude.tail: empty list
Prelude> head []
*** Exception: Prelude.head: empty list
</pre>
<code>tail [1]</code> が <code>[]</code> になるのは <code>[1]</code> が <code>1:[]</code> だから，かな． </li>
<li>pair (要素2つの tuple) : <code>fst</code> で 1つめの要素を，<code>snd</code> で 2つめの要素を取得．
<pre style="background:#000;color:#f8f8f8">
Prelude> fst (2,5)
2
Prelude> fst (True,"noo")
True
Prelude> fst( snd ( (True, 3), (2,"there")))
2
Prelude> fst (2,3,1)

&lt;interactive>:5:5:
    Couldn't match expected type `(a0, b0)'
                with actual type `(t0, t1, t2)'
    In the first argument of `fst', namely `(2, 3, 1)'
    In the expression: fst (2, 3, 1)
    In an equation for `it': it = fst (2, 3, 1)
</pre>
pair にしかこれは使えないんだ，すまない．（<code>(2,3)</code> と <code>(2,3,4)</code> では type が違うからね）
</li>
</ul>
</p>
<p>練習問題．
<ol>
<li><code>( ("Hello", 4), True)</code> から 4 を取り出してみよう．</li>
<li>tuple で list の 頭と残りを返す関数書いてみよう．</li>
<li><code>head</code> と <code>tail</code> で list の 5番目の要素を返す関数を書いてみよう．どこかどう面倒くさいか考えておこう．
</ol>
</p>
