<meta charset="utf-8">
en.wikibooks の <a href="http://en.wikibooks/org/wiki/Haskell">Haskell</a>, pdf 版 をベースに．<br />
wikibooks のライセンスを継承して CC-BY-SA です．
<h2>Getting set up</h2>
<p>
まずは haskell のインストール． Glasgow Haskell Compiler, GHC がおすすめ．<br />
ちなみにこの GHC自体も Haskell で書かれてるらしい<small>（だからソースから自分でビルドしようとするとめっちゃ苦労するらしい）</small>．<br />
ubuntu とかなら
<pre style="background:#000;color:#f8f8f8">
$ sudo apt-get update
$ sudo apt-get install ghc
</pre>
でよい． コンパイラとともに GHCi (i for <i>interacitve</i>)という interactive environment がついてきます．<br />
若干 python とかのインタープリタとは趣が違うんやけど，まあともかくこの人とお話していきましょう．<br />
linux ならたとえば
<pre style="background:#000;color:#f8f8f8">
$ ghci
GHCi, version 7.6.2: <span style="color:#e18964;text-decoration:underline">http://www.haskell.org/ghc/</span>  :? for help
Loading package ghc-prim ... linking ... done.
Loading package integer-gmp ... linking ... done.
Loading package base ... linking ... done.
Prelude> 
</pre>
というかんじ．<small>かっこいいアスキーアートが出てくる例が多いみたいやけどなんか僕の環境では出てきません． </small><br />
ここで <code> loading package </code>とかやってくれてますが，<br />
これによって built-in functions や modules にはだいたいアクセスできる．<br />
<code>Prelude></code> は prompt ってやつで，ここにコマンドを書き込んでいく．<small>prelude の意味はそのうち出てくるはず．</small><br />
</p>
<p>
というわけで四則とかそのへん．まだすごくない．
<pre style="background:#000;color:#f8f8f8">
Prelude> 2+2
4
Prelude> 5 * 4 + 3 
23
Prelude> 2^5
32
</pre>
指数は <code>^</code>で書くぜってあたり以外は特記事項なし．<br />
...と思ってたら， <code>^</code> は <code>(Integral b, Num a) => a -> b -> a </code>. <br />
<small>（この記法の意味はしばらく先に出てきます．とりあえずは数なものと Integral なもの（こっちが第2引数）を受け取って数を返す（数学で言う）函数ってこと．）</small><br />
例えば
<pre style="background:#000;color:#f8f8f8">
Prelude> 2^1.2
</pre>
はエラーを，
<pre style="background:#000;color:#f8f8f8">
Prelude> 2^(-1)
</pre>
は Exception を返してくるみたい．<br />
こういうのも含めて指数を書くときは <code> ** </code> で．
<pre style="background:#000;color:#f8f8f8">
Prelude> :t (**)
(**) :: Floating a => a -> a -> a
</pre>
まとめると
<pre style="background:#000;color:#f8f8f8">
Prelude> 2**(-1)
0.5
Prelude> 2**0.5
1.4142135623730951
Prelude> 1.0^2
1.0
</pre>
これからお世話になる ghci はソースファイル読み込んだりとかもちゃんとできる優秀なひと，らしい．
</p>

<p><h2>Variables and functions</h2>
さっきのは単にその場所で計算しっぱなしやったけど，これは不便よね．<br />
というわけでそういうのは value をもつ variable に保存されます．例えば半径5の円の面積
<pre style="background:#000;color:#f8f8f8">
ghci>3.1416 * 5^2
78.53999999999999
</pre>
<small>#これ<code>ghci></code>ってなってるけどたとえば <code>Prelude></code> でやっていい．</small><br />
やけど，いちいち打ち込むのはあんまりです．<br />
この場合すでに pi っていう variable が define されてて，
<pre style="background:#000;color:#f8f8f8">
ghci> pi
3.141592653589793
ghci> pi * 5^2
78.53981633974483
</pre>
善哉．<br />
この辺りで最後に表示されるのは結局，式とか函数を評価していって最後に値がひとつ残った時にそれを表示，ということが行われてます．<br />
なお Haskell に変数はない，という言い方も多い（値を "束縛" することはあっても，それを変化させられないから）けど，<br /> 
ここではとりあえず variable と呼んでおきます．なんかもう全部（数学で言う）関数みたいなもん，みたい．
</p>
<h3>Haskell source files</h3>
<p>ではでは僕らも変数を定義してみよう．と，いうところで…
<pre style="background:#000;color:#f8f8f8">
Prelude> r = 3
</pre>
と何も考えずにやると
<pre style="background:#000;color:#f8f8f8">
Prelude> r = 3

&lt;interactive>:9:1: parse error on input '='
</pre>
怒られました．このあたりが python のインタープリタと根本的に違うところ，かなあ．<br />
これを回避するには
<pre style="background:#000;color:#f8f8f8">
Prelude> let r = 3
</pre>
とやれば良く，以降もたまに使いますが，基本的には以下でやる通り，<br />
ソースファイルを作って読み込んでもらって interacitve にいろいろやっていく<br />
のがとりあえずは吉です． 
</p>
<p>
とりあえずこのあたりは一旦置いといて．変数定義はソースファイルから読み込んでやりましょう．<br />
<code>Varfun.hs</code> をつくる（Haskell の場合拡張子は .hs が普通みたい）．
<pre style="background:#000;color:#f8f8f8">
r <span style="color:#e28964">=</span> <span style="color:#3387cc">5.0</span>
</pre>
Haskell さん，こう見えて whitespace sensitive なので行頭にスペースは入れないように．<br />
なお <code>=</code> 前後のスペースはどうでも良い模様．<br />
で，これを GHCi から読み込むときには<code>:cd</code>で cd して <code>:load</code> か <code>:l</code>で読み込む．
<pre style="background:#000;color:#f8f8f8">
Prelude> :load Varfun.hs 
[1 of 1] Compiling Main             ( Varfun.hs, interpreted )
Ok, modules loaded: Main.
*Main> r
5.0
</pre>
という感じですね．Tab 補完も効く模様．<br />
使いたいファイルがひとつだけなら ghci を起動するときに引数として渡してやってもよいようだ．
<pre style="background:#000;color:#f8f8f8">
$ ghci Varfun.hs
GHCi, version 7.6.2: <span style="color:#e18964;text-decoration:underline">http://www.haskell.org/ghc/</span>  :? for help
Loading package ghc-prim ... linking ... done.
Loading package integer-gmp ... linking ... done.
Loading package base ... linking ... done.
[1 of 1] Compiling Main             ( varfun.hs, interpreted )
Ok, modules loaded: Main.
*Main> 
</pre>
変数名は小文字の英字で始めねばならず，残りは文字，数字，underscore (_), tick (') を使用できます．<br />
他の言語なら myfoo みたいな付け方をする場合には foo' とか使うのもいいかもしれません．<br />
そして，本来なら Haskell さんは静的型付け言語なのですが，型推論をやってくれるので今は無指定で大丈夫です．<br />
(python みたいに動的型付けなのではなくて，向こうが適切に推論して型を振ってくれる，ということ）．
</p>
<p>
もうちょっと書き足してみよう．エディタから<code>Varfun.hs</code>を編集
<pre style="background:#000;color:#f8f8f8">
r <span style="color:#e28964">=</span> <span style="color:#3387cc">5</span>
area <span style="color:#e28964">=</span> <span style="color:#dad085">pi</span>*r^<span style="color:#3387cc">2</span>
</pre>
で ghci から <code>:reload</code> か <code>:r</code>で読み込み（引数は不要）．<br />
こんなかんじになるはず
<pre style="background:#000;color:#f8f8f8">
*Main> :r
[1 of 1] Compiling Main             ( Varfun.hs, interpreted )
Ok, modules loaded: Main.
*Main> area
78.53981633974483
*Main> area / r^2
3.141592653589793
*Main> 
</pre>
めでたし． <br />
こうしてファイルから ghci に読み込むのじゃなくて， ghc でコンパイルすることも（もちろん）できます．<br />
そのへんもまたそのうちに．そのうちにっていうか
<pre style="background:#000;color:#f8f8f8">
$ ghc foo.hs
</pre>
でいいんですけどね．main 関数書かないといけないとかそういうのがあるので．
</p>

<h3>Comments</h3>
<p>Haskell のコメントは <code>--</code> に続けて書く(LaTeX の <code>%</code>, python の <code>#</code> 相当)．
<pre style="background:#000;color:#f8f8f8">
x <span style="color:#e28964">=</span> <span style="color:#3387cc">5</span>     <span style="color:#aeaeae;font-style:italic">-- The variable x is 5.</span>
<span style="color:#aeaeae;font-style:italic">-- y = 7</span>
</pre>
行の最後まで続かないの，あるいは複数行に渡るのは<code>{- comments -}</code>.
<pre style="background:#000;color:#f8f8f8"> x <span style="color:#e28964">=</span> <span style="color:#aeaeae;font-style:italic">{- Don't do this just because you can. -}</span> <span style="color:#3387cc">5</span> 
</pre>
</p>

<h3>Variables in imperative languages</h3>
<p>
大事なこと言います．
<blockquote>
Haskell では，変数の値は変化しない．
</blockquote>
もう一度言います．
<blockquote><b>Variables do not vary.</b></blockquote>
大事なことだから三回目
<blockquote>
<pre><big><b>
＿人人人人人人人人人人人人＿
＞　変数の値は変化しない　＜
￣Y^Y^Y^Y^Y^Y^Y^Y^Y^Y^Y￣
</big></b></pre>
</blockquote>
<b>な，なんだってーーーーーー！！</b><br /><br />
</p>
<p>
<code>DoubleDeclarations.hs</code>
<pre style="background:#000;color:#f8f8f8">
a <span style="color:#e28964">=</span> <span style="color:#3387cc">3</span>
a <span style="color:#e28964">=</span> <span style="color:#3387cc">5</span>
</pre>
で
<pre style="background:#000;color:#f8f8f8">
Prelude> :l DoubleDeclarations.hs 
[1 of 1] Compiling Main             ( DoubleDeclarations.hs, interpreted )

DoubleDeclarations.hs:2:1:
    Multiple declarations of `a'
    Declared at: DoubleDeclarations.hs:1:1
                 DoubleDeclarations.hs:2:1
Failed, modules loaded: none. 
</pre>
<i><code>Multiple declarations of `a'.</code></i><br />
<code> a </code> が2回定義されてるやん，おかしいやん，って言われてしまいました．<br />
<small>ちなみにこのように ghci のエラー表示は非常に親切かつ賢くて，丁寧に読むとかなり色々わかります，</small> <br />
これ，命令型言語なら， 1行目で a っていう ''箱'' に 3 が入り， 2行目で 5 になる，と読むところですが，<br />
我らが純粋関数型言語では，そうはならないわけです．数学で a = 3 って書いた時みたい．<br />
こんなのも：
<code> foo.hs </code> (ファイル名面倒になった)
<pre style="background:#000;color:#f8f8f8">
a <span style="color:#e28964">=</span> <span style="color:#3387cc">3</span>
a <span style="color:#e28964">=</span> a<span style="color:#e28964">+</span><span style="color:#3387cc">1</span>
</pre>
（これが動かないだと…!!）<br />
これは a の increment ではなく， a の再帰定義とみなされます．<br />
</p>
<p> 
これで直ちに嬉しいことの一つが，変数定義の順番を気にしなくて良いこと．
<pre style="background:#000;color:#f8f8f8">
y <span style="color:#e28964">=</span> x*<span style="color:#3387cc">2</span>
x <span style="color:#e28964">=</span> <span style="color:#3387cc">3</span>
</pre>
と
<pre style="background:#000;color:#f8f8f8">
x <span style="color:#e28964">=</span> <span style="color:#3387cc">3</span>
y <span style="color:#e28964">=</span> x*<span style="color:#3387cc">2</span>
</pre>
は同じ．もちろん y を実際に使うときには x の値が必要になりますが，<br />
そうして実際の特定の数値が必要になるまでは，べつに重要ではないというわけです．
</p>
<p>
でもそれどうするんですか，<code> for </code>文 loop とかどうすればいいんですか．<br />
→わくわくですよね．とにかく，ほんとにこれでうまく行くらしい． Haskell かっこいい．<br />
<small>実は，僕が Haskell をもうちょっとやろうと思った決定的な瞬間がこのあたりだったりします．<br />
すごくかっこよくて，すごく気持ちよさそう．もっと知りたいな，と思いました．それでいま勉強中．</small><br />
en.wikibooks から引用：
<blockquote><i>
By now, you probably look very incredulous and wonder how you can actually do anything at all in Haskell where variables don't change. But trust us; as we hope to show you in the rest of this book, you can write every program under the sun without ever changing a single variable!  In fact, variables that don't change make life so much easier because it makes programs much more predictable. It's a key feature of purely functional programming, not a bug.
</i></blockquote>
</p>
<h3> Functions </h3>
<p>
複数の円の面積を求めたい場合，
<pre style="background:#000;color:#f8f8f8">
<span style="color:#aeaeae;font-style:italic">-- twoareas.hs</span>
r <span style="color:#e28964">=</span> <span style="color:#3387cc">5</span>
area <span style="color:#e28964">=</span> <span style="color:#dad085">pi</span>*r^<span style="color:#3387cc">2</span>
r2 <span style="color:#e28964">=</span> <span style="color:#3387cc">3</span>
area2 <span style="color:#e28964">=</span> <span style="color:#dad085">pi</span>*r2^<span style="color:#3387cc">2</span>
</pre>
…なんてやるのはあまりにひどい．ここで function の出番です．<p />
<p>
function は argument value (or parameter) をとって，結果の値を与えるもの．<br />
数学の函数と (Haskell でいう関数は！）一緒です．<br />
書き方はシンプル，variable 定義するのと同じノリで，左辺に argument を書いておく．
<pre style="background:#000;color:#f8f8f8">
area r <span style="color:#e28964">=</span> <span style="color:#dad085">pi</span> * r^<span style="color:#3387cc">2</span> <span style="color:#aeaeae;font-style:italic">-- 数式でいうと A(r) = \pi * r^2</span>
</pre>
関数名，space あけて argument(s) の順に書いて括弧は使わない．<br />
<code>def</code> みたいな特別な syntax はなく， <code>r = 5</code> って定義したのと同じノリで，この書き方で定義する．<br />
</p>
<p>
さてではこれを call してみよう．とりあえずは ghci で読み込んで
<pre style="background:#000;color:#f8f8f8">
*Main> area 3
28.274333882308138
*Main> area 5
78.53981633974483
*Main> :t area
area :: Floating a => a -> a
</pre>
<code> :t </code> のところ，まだ出てきてませんが type のことをやれば意味がわかるので少しお待ちを．
</p>
<p>
関数の引数を示すのに括弧で括ることはしませんが，expressions （値を与えるあらゆる code) を纏めて一緒に評価させるときには
<pre style="background:#000;color:#f8f8f8">
area (<span style="color:#3387cc">5</span><span style="color:#e28964">+</span><span style="color:#3387cc">3</span>)
</pre>
みたいにくくる．<br />
この場合は最初に <code>5+3</code> （もちろん 8 ）を計算して，その <code>area</code> を計算します．一方
<pre style="background:#000;color:#f8f8f8">
area <span style="color:#3387cc">5</span> <span style="color:#e28964">+</span> <span style="color:#3387cc">3</span>
</pre>
ではまず <code>area 5</code> を計算して，それに <code>3</code> を足すことになります．<br />
これは掛け算が足し算より順位が高いのとおなじように， function call が先に行われるということ．<br />
では
<pre style="background:#000;color:#f8f8f8">
area <span style="color:#3387cc">5</span> * <span style="color:#3387cc">3</span>
area <span style="color:#3387cc">1</span> ^ <span style="color:#3387cc">3</span>
</pre>
はそれぞれどうなるでしょう．（演習課題？）
</p>
<p>
せっかくだから，もうちょっと関数を書いてみよう．
<pre style="background:#000;color:#f8f8f8">
double x <span style="color:#e28964">=</span> <span style="color:#3387cc">2</span> * x
quadruple x <span style="color:#e28964">=</span> double(double x)
square x <span style="color:#e28964">=</span> x * x
half x <span style="color:#e28964">=</span> x <span style="color:#e28964">/</span> <span style="color:#3387cc">2</span>
</pre> 
うむ．
</p> 
<h4> Evaluation </h4>
<p>
GHCi に expression を打ち込んだ時に何が起こるのか． <br />
Enter 押したら ghci は打ち込んだ expression を 評価 --evaluate-- します．<br />
これはつまり， 関数を定義で置き換え，結果を計算して，最後に値がひとつだけ残るまでそれをやる，ということ．<br />
さっきの <code> area 5 </code> でやってみましょうか．
<pre style="background:#000;color:#f8f8f8">
    area <span style="color:#3387cc">5</span>
<span style="color:#e28964">=></span>   <span style="color:#aeaeae;font-style:italic">{- 定義の area r = を 右辺の pi * r^2 で置き換え-}</span>
    <span style="color:#dad085">pi</span> * <span style="color:#3387cc">5</span>^<span style="color:#3387cc">2</span>
<span style="color:#e28964">=></span> <span style="color:#aeaeae;font-style:italic">{- pi を数値に置き換え-}</span>
    <span style="color:#3387cc">3.141592653589793</span> * <span style="color:#3387cc">5</span>^<span style="color:#3387cc">2</span>
<span style="color:#e28964">=></span> <span style="color:#aeaeae;font-style:italic">{- 指数(^)を適用 -}</span>
    <span style="color:#3387cc">3.141592653589793</span> * <span style="color:#3387cc">25</span>
<span style="color:#e28964">=></span> <span style="color:#aeaeae;font-style:italic">{- 掛け算 -}</span>
    <span style="color:#3387cc">78.53981633974483</span>
</pre>
あ，別に <code> => </code> は Haskell さん的なアレじゃないよ．
</p>
<p>
練習問題．
<ul>
	<li> 少し前の <code> quadruple 5 </code> は ghci さんにどう評価されるか．再掲すると
<pre style="background:#000;color:#f8f8f8">
double x <span style="color:#e28964">=</span> <span style="color:#3387cc">2</span> * x
quadruple x  <span style="color:#e28964">=</span> double(double x)
</pre>
	</li>
	<li>引数の半分から 12 を引く関数書いてみよう．</li>
</ul>
</p>
<h4> Multiple parameters </h4>
<p>
もちろん引数は一つとは限らないよー．書き方は前と一緒でここでも括弧は使わない．<br />
縦と横与えられて長方形の面積：
<pre style="background:#000;color:#f8f8f8">
areaRect l w <span style="color:#e28964">=</span> l * w
</pre>
で
<pre style="background:#000;color:#f8f8f8">
*Main> areaRect 5 10
50
</pre>
直角三角形の面積求めるぜ
<pre style="background:#000;color:#f8f8f8">
areaRightTriangle b h <span style="color:#e28964">=</span> (b * h) <span style="color:#e28964">/</span><span style="color:#3387cc">2</span>
</pre>
使うときはこんなかんじに引数同士をスペースで区切る．<br />
だから(?)括弧使って評価の順番を指定しないと誤解が生じることもあるわけですねー．
<pre style="background:#000;color:#f8f8f8">
quadruple x <span style="color:#e28964">=</span> double double x
</pre>
と，書くとします．実は関数も他の関数の引数になれちゃうので誤解が起きる．<br />
関数を関数に投げる話はまた後でするとして，とりあえずちゃんと誤解を解くために
<pre style="background:#000;color:#f8f8f8">
quadruple x <span style="color:#e28964">=</span> double (double x)
</pre>
とすればめでたく思っているとおりに通る．<br />
ついでに一応確認しとくと引数の順番は書いてあるままです．
<pre style="background:#000;color:#f8f8f8">
<span style="color:#dad085">subtract</span> x y <span style="color:#e28964">=</span> x <span style="color:#e28964">-</span> y
</pre>
なら<code> subtract 10 5 </code> は <code> 5 </code>, <code> subtract 5 10 </code> は <code> -5.</code><br />
なおいままで何の気無しに使ってた <code>+</code> とかも関数で，<code> (+) </code> と書くと本来の関数としての syntax で使えます．
<pre style="background:#000;color:#f8f8f8">
Prelude> (+) 3 2 
5
</pre>
演習．
<ul>
	<li>直方体の体積出す関数書いてみよう．</li>
	<li>Giza のピラミッドって大体どのくらいの数の石でできてるだろう？ GHCi さんの助けを借りて計算してみよう．</li>
</ul>
</p>
<p>
関数使って関数作るのももちろんできるよ<br />
長方形と正方形の面積求めるもの
<pre style="background:#000;color:#f8f8f8">
areaRect l w <span style="color:#e28964">=</span> l * w
areaSquare s <span style="color:#e28964">=</span> areaRect s s
</pre>
こういうのできるの，後々わかってくるけど超便利．<br />
演習．
<ul>
<li> 円柱の体積求める関数書いてみよう．</li>
</ul>
</p>
<h3> Local definitions </h3>
<h4> <code>where</code> clauses </h4>
<p>
その関数の中でしか使わへんようなやつをいちいちきちんと定義するのもアレなので．<br />
Heron の公式 (A = \sqrt{s (s-a) (s-b) (s-c)} where s = (a+b+c)/2) ですがこれを Haskell でそのまま書けて
<pre style="background:#000;color:#f8f8f8">
heron a b c <span style="color:#e28964">=</span> <span style="color:#dad085">sqrt</span> ( s*(s<span style="color:#e28964">-</span>a)*(s<span style="color:#e28964">-</span>b)*(s<span style="color:#e28964">-</span>c) )
    <span style="color:#e28964">where</span> 
    s <span style="color:#e28964">=</span> (a<span style="color:#e28964">+</span>b<span style="color:#e28964">+</span>c) <span style="color:#e28964">/</span> <span style="color:#3387cc">2</span>
</pre>
<code>where</code> と local definitions はスペース4つでインデントして区別されます．<br />
このへん python みたいに whitespace sensitive なわけですねー．<br />
そしてこれを，
<pre style="background:#000;color:#f8f8f8">
heron a b c <span style="color:#e28964">=</span> <span style="color:#dad085">sqrt</span> ( s*(s<span style="color:#e28964">-</span>a)*(s<span style="color:#e28964">-</span>b)*(s<span style="color:#e28964">-</span>c) ) <span style="color:#aeaeae;font-style:italic">-- s はここでは定義されてない</span>
s <span style="color:#e28964">=</span> (a<span style="color:#e28964">+</span>b<span style="color:#e28964">+</span>c) <span style="color:#e28964">/</span> <span style="color:#3387cc">2</span>  <span style="color:#aeaeae;font-style:italic">-- ここでは a, b, c が定義されてない</span>
</pre>
と書くと，<code> s = (a+b+c)/2 </code> のところは <code> heron </code> の右辺の定義の一部としては解釈されないので，<br />
所定の結果は得られません．
</p>
<p>他の例．
<pre style="background:#000;color:#f8f8f8">
areaTriangleTrig a b c <span style="color:#e28964">=</span> c * height <span style="color:#e28964">/</span> <span style="color:#3387cc">2</span> <span style="color:#aeaeae;font-style:italic">--三角関数で</span>
    <span style="color:#e28964">where</span>
    cosa <span style="color:#e28964">=</span> (b^<span style="color:#3387cc">2</span> <span style="color:#e28964">+</span> c^<span style="color:#3387cc">2</span> <span style="color:#e28964">-</span> a^<span style="color:#3387cc">2</span>) <span style="color:#e28964">/</span> (<span style="color:#3387cc">2</span>*b*c) <span style="color:#aeaeae;font-style:italic">--余弦定理</span>
    sina <span style="color:#e28964">=</span> <span style="color:#dad085">sqrt</span>(<span style="color:#3387cc">1</span> <span style="color:#e28964">-</span> cosa^<span style="color:#3387cc">2</span>)
    height <span style="color:#e28964">=</span> b * sina

areaTriangleHeron a b c <span style="color:#e28964">=</span> result <span style="color:#aeaeae;font-style:italic">--ヘロンの公式から</span>
    <span style="color:#e28964">where</span>
    result <span style="color:#e28964">=</span> <span style="color:#dad085">sqrt</span>(s*(s<span style="color:#e28964">-</span>a)*(s<span style="color:#e28964">-</span>b)*(s<span style="color:#e28964">-</span>c))
    s <span style="color:#e28964">=</span> (a<span style="color:#e28964">+</span>b<span style="color:#e28964">+</span>c) <span style="color:#e28964">/</span> <span style="color:#3387cc">2</span>
</pre>
</p>
<h4> Scope </h4>
<p>
上の例で <code> a </code> とか <code> b </code> とか <code> c </code> とかたくさん出てきたけど，大丈夫なんか．<br />
これはありがたいことに思ったとおりに動く：(<code>let</code> のことは一旦おいといて．)
<pre style="background:#000;color:#f8f8f8">
Prelude> let r = 0
Prelude> let area r = pi * r^2
Prelude> area 5
</pre>
最初に <code>r = 0</code> といってるから <code>area r = pi * r^2</code> で問答無用に 0や! とはなりません．<br />
要するに 2つの<code> r </code> は別のものを指してるというわけ．<br />
詳しくはここでは省くけど， scope っていう（他の言語にもあるよね）仕組みで上手くいくようになってるかんじです．<br />
つまり，<code>=</code> で結ぶと，以降その定義の scope に照らして適切である範囲で右辺と置き換えられる，みたいな．<br />
感じ．詳細がなくてすっきりしないけど．
</p>
<h2> Truth Values</h2>
<h3> Equality and other comparisons / Boolean Values  </h3>
<p>
アレだ，数学で <code>=</code> って書いてもどっちかいうと proposition としてのそれがあるようなかんじで．
2つの値の比較には <code>==</code> を使う．
<pre style="background:#000;color:#f8f8f8">
Prelude> 2 + 3 == 5
True
</pre>
<code>True</code> あるいは <code>False</code> が帰ってくる．大小比較は <code> >, <, <=, >=</code> で．
<pre style="background:#000;color:#f8f8f8">
Main*> area 5 &lt; 50
</pre>
みたいな書き方ももちろん出来ます．<br />
帰ってくる <code>True</code> とかは Boolean values, ないし truth values と呼ばれます．お見知りおきを．
</p>

<h3> An introduction to types </h3>
<p>
Type の話だ！楽しみにしましょう！わーい！<br />
Truth values が values というてるけど，これはマジでそういうことで， 数値と同じ意味で値を持ってる．<br />
例えば
<pre style="background:#000;color:#f8f8f8">
Prelude> True == True
True
Prelude> True == False
False
</pre>
ってな感じ．では「2 と True は等しいでしょうか？」
<pre style="background:#000;color:#f8f8f8">
Prelude> 2 == True

&lt;interactive>:3:1:
    No instance for (Num Bool) arising from the literal `2'
    Possible fix: add an instance declaration for (Num Bool)
    In the first argument of `(==)', namely `2'
    In the expression: 2 == True
    In an equation for `it': it = 2 == True
</pre>
そんな比較はできません．<small>上で ghci さんが何を言ってるのかは後ほど読めるようになる．</small><br />
左辺は数 (type としては <code>Num</code>), 右辺は Boolean value (<code>Bool</code>)<br />
型 (type) が違うので，比較のしようがないのです．<br />
これまでは ghci が勝手に解釈してくれていましたが，自分で型を指定することもでき，<br />
Haskell のこの型システムは，ちゃんと意味が通るように物事を動かす上で非常に強力です．<br />
超大事で格好いいので次の章はこの型の話．その前に今の話を片付けてしまいましょう． 
</p>
<h3> Infix operators </h3>
<p>
さっきの 2 と True を調べた時，
<pre style="background:#000;color:#f8f8f8">
In the first argument of `(==)', namely `2'
</pre>
さて ghc さんは 2 を first argument of (==) と呼んでるわけやけれども，この (==) も普通の函数．<br />
ただ syntax 的にちょっと違って， Haskell ではこういう，<br />
名前が英数以外の記号だけでできてる 2 変数関数 は中置できることになってるらしい．<br />
infix operators, と呼ぶそうな．普通の関数みたいに使うときは ( ) でくくる．
<pre style="background:#000;color:#f8f8f8">
Prelude (==) (4 + 9) 13
True
</pre>
前にちょっと触れた <code>(+)</code> とかもこの類ですね．<br />
逆にさっきの <code>areaRect</code> みたいな関数を中置したい時は ` `  でくくって
<pre style="background:#000;color:#f8f8f8">
<span style="color:#3387cc">2</span> <span style="color:#e28964">`areaRect`</span> <span style="color:#3387cc">5</span>
</pre>
と書ける．これではあんまり嬉しさもないけど，<code>3 `mod` 2</code> みたいな書き方は素敵そう．<br />
というわけで <code>==</code> も <code>+</code> も <code> >= </code> もなんでもかんでも関数です．
</p>
<h3> Boolean operations </h3>
and は <code>(&&)</code>, or は <code>(||)</code>, <code>not</code> で論理否定．<br />
いずれもさっきの infix operator な記法に従います．
<pre style="background:#000;color:#f8f8f8">
Prelude> (3 &lt; 8) &amp;&amp; (False == False)
True
Prelude> (&amp;&amp;) (3 &lt; 8) (False == False)
True
Prelude> not (5*2 == 10)
False
</pre>
みたいな感じ．なお， not equal to については <code>/=</code> (\neq に形を似せたという噂？) とも書ける．あえて書くなら<br />
<pre style="background:#000;color:#f8f8f8">
x <span style="color:#e28964">/=</span> y <span style="color:#e28964">=</span> <span style="color:#dad085">not</span> (x <span style="color:#e28964">==</span> y)
</pre>
というかんじ（この書き方で完全に正しい）．一瞬あれって思うかもしれないが落ち着いて．
<h3> Guards </h3>
<p>
絶対値を吐く関数を書いてみましょう．Haskell に <code>abs</code> 関数があるので自分で書かなくてもいいんですが．<br />
書きたいのは，数式で書くと
<pre>
|x| =  x    if x >= 0
      -x    if x <  0
</pre>
ってこと．<br />
</p>
<p>
さて Haskell で書くでーーーー！<br />
<pre style="background:#000;color:#f8f8f8">
myabs x
      <span style="color:#e28964">|</span>  x <span style="color:#e28964">&lt;</span> <span style="color:#3387cc">0</span>      <span style="color:#e28964">=</span> <span style="color:#3387cc">0</span> <span style="color:#e28964">-</span> x
      <span style="color:#e28964">|</span>  <span style="color:#dad085">otherwise</span>  <span style="color:#e28964">=</span> x
</pre>
大変読みやすくまとまっております．
<ul>
<li>まず普通に書き始めて</li>
<li><code>=</code> 書かずに改行，インデントを置いて（これは文法上必要）場合分けを書く．
<ul><li>場合分けは <code>|</code> に続けて，Bool 値を返す expression, <code>=</code> とその場合の右辺の順．</li>
<li>それぞれが guard と呼ばれるらしいぜ！</li>
<li>otherwise は otherwise. 別になくても構わない．さっきので言えば <code>x<=0</code> で書いてもよかった．<br />
けどどれも True にならなかったら runtime error になる（バグ取り大変）から使っといたほうがいい．</li></ul></li>
</ul>
</p>
<p>
注意点．
<ul>
<li> <code>otherwise</code> 格好いいけど実は
<pre style="background:#000;color:#f8f8f8">
<span style="color:#dad085">otherwise</span> <span style="color:#e28964">=</span> <span style="color:#cf6a4c">True</span>
</pre>
って定義されてるだけらしい．賢いな．でもだから最後に置かなあかんよ．</li>
<li>
わざわざ <code>0 - x</code> って書いたけど，この場合は関数としてやなくてあくまで記法上の簡略化として 
<code> -x </code> とだけ書いてもよかった．ただ <code> 3 - -5</code> みたいな書き方は括弧なしでは通らないので気をつけよう．
</li>
</ul>
</p>
<h4> <code>where</code> and Guards </h4>
<p>
<code>where</code> と guard の組み合わせは使いやすい．<br />
二次方程式 ax^2 + bx + c = 0 の解の個数
<pre style="background:#000;color:#f8f8f8">
numOfSolutions a b c 
    <span style="color:#e28964">|</span> disc <span style="color:#e28964">></span> <span style="color:#3387cc">0</span>  <span style="color:#e28964">=</span> <span style="color:#3387cc">2</span>
    <span style="color:#e28964">|</span> disc <span style="color:#e28964">==</span> <span style="color:#3387cc">0</span> <span style="color:#e28964">=</span> <span style="color:#3387cc">1</span>
    <span style="color:#e28964">|</span> <span style="color:#dad085">otherwise</span> <span style="color:#e28964">=</span> <span style="color:#3387cc">0</span>
        <span style="color:#e28964">where</span> 
        disc <span style="color:#e28964">=</span> b^<span style="color:#3387cc">2</span> <span style="color:#e28964">-</span> <span style="color:#3387cc">4</span>*a*c
</pre>
ここで <code>where</code> の scope は guard 全部の下に入ってるってことらしい．
</p>

<h2> Type Basics!!!!!!!!!!! </h2>
ｳｯﾋｮｵｵｵｵｵｵｵｵｵｵｵｵｵｵｵｵｵｵ type ﾀﾞｱｱｱｱｱｱｱｱｱ<br />
<p>
…コホン．
<ul>
<li>Haskell での型は大文字から始まる．String が string. 自分で型作るのもできるぜ </li>
<li>例えば電話番号とかは，もちろん普通の数として扱ってもいいけど，
<code>TelephoneNumber</code> みたいな型として見たほうが情報をたくさん得られたり，要らん混乱を弾いたりできそう．</li>
<li> ghci で <code>:t</code> ないし <code>:type</code> コマンド使ったらどの type か教えてくれるぜ！</li>
</ul>
</p>
<p>
というわけで :t やってみるぞー！！<br />
</p>
<p>
いろんな値
<pre style="background:#000;color:#f8f8f8">
Prelude> :t True
True :: Bool
Prelude> :t (3 &lt; 2)
(3 &lt; 2) :: Bool
Prelude> :t 'a'
'a' :: Char
Prelude> :t "a"
"a" :: [Char]
Prelude> :t 'ab'

&lt;interactive>:1:1:
    Syntax error on 'ab'
    Perhaps you intended to use -XTemplateHaskell
Prelude> :t "ab"
"ab" :: [Char]
Prelude> :t 31
31 :: Num a => a
Prelude> :t 3.2
3.2 :: Fractional a => a
Prelude> :t (2/3)
(2/3) :: Fractional a => a
</pre>
<code> Fractional a => a</code>とかはあとで．a は Fractional やでっていう束縛みたいなもの．<br />
<code>String</code> は <code>[Char]</code> のこと（どっちでも書いてもいい）で，<br />
<code>[Char]</code> は <code>Char</code> の list のこと．<br />
</p>
<p>
関数とか．引数が複数あるときは<code>甲 :: (引数1)->(引数2)->..->(引数n)->(返り値）</code> と表す．
<pre style="background:#000;color:#f8f8f8">
Prelude> :t not
not :: Bool -> Bool
Prelude> :t (+)
(+) :: Num a => a -> a -> a
Prelude> :t (/)
(/) :: Fractional a => a -> a -> a
Prelude> :t (^)
(^) :: (Integral b, Num a) => a -> b -> a
Prelude> :t (**)
(**) :: Floating a => a -> a -> a
Prelude> :t ^ --ちなみにこれは
&lt;interactive>:1:1: parse error on input `^'
Prelude> let areaRect x y = x * y
Prelude> :t areaRect -- 自分では型指定してないけど推論してくれてる
areaRect :: Num a => a -> a -> a
</pre>
アレやで， <code>1 + </code> とかも関数やで
<pre style="background:#000;color:#f8f8f8">
Prelude> :t (3&lt;)
(3&lt;) :: (Num a, Ord a) => a -> Bool
Prelude> :t (1+)
(1+) :: Num a => a -> a
</pre>
<p>
この <code>::</code> は type signature と言われ，自分で型宣言するときもこうすればよい．<br />
<pre style="background:#000;color:#f8f8f8">
<span style="color:#89bdff">a</span> <span style="color:#e28964">::</span> <span style="color:#9b859d">Integer</span>
a <span style="color:#e28964">=</span> <span style="color:#3387cc">3</span>
<span style="color:#89bdff">mynot</span> <span style="color:#e28964">::</span> <span style="color:#9b859d">Bool</span> <span style="color:#e28964">-></span> <span style="color:#9b859d">Bool</span>
mynot arg
    <span style="color:#e28964">|</span> arg        <span style="color:#e28964">=</span> <span style="color:#cf6a4c">False</span>
    <span style="color:#e28964">|</span> <span style="color:#dad085">otherwise</span>  <span style="color:#e28964">=</span> <span style="color:#cf6a4c">True</span>
</pre>
的な．複数同じ型を持ってる場合は <code>a,b :: (type)</code> ってまとめてかけるぜ．
</p>
<p>
具体例を考えてみようか．<code>chr</code> と <code>ord</code>, ASCII な感じの番号と文字の相互変換．<br />
これを使うには <code>Data.Char</code> を import する． ghci からなら
<pre style="background:#000;color:#f8f8f8">
Prelude> :m Data.Char 
</pre>
(または <code>:module</code>) で import して
<pre style="background:#000;color:#f8f8f8">
Prelude Data.Char> chr 97
'a'
Prelude Data.Char> chr 96
'`'
Prelude Data.Char> ord 'm'
109
</pre>
.hs 書くなら
<pre style="background:#000;color:#f8f8f8">
<span style="color:#e28964">import</span> <span style="color:#9b859d">Data.Char</span>
</pre>
python みたいに <code>Data.Char.chr(97)</code> とはしない．これの型は
<pre style="background:#000;color:#f8f8f8">
chr :: Int -> Char
ord :: Char -> Int
</pre>
</p>
<p>
<code>xor</code> とか書いてみるか．
<pre style="background:#000;color:#f8f8f8">
xor p q <span style="color:#e28964">=</span> (p <span style="color:#e28964">||</span> q) &amp;&amp; <span style="color:#dad085">not</span> (p &amp;&amp; q)
</pre>
Bool と Bool で Bool 返すので
<pre style="background:#000;color:#f8f8f8">
Prelude> :l xor.hs 
[1 of 1] Compiling Main             ( xor.hs, interpreted )
Ok, modules loaded: Main.
*Main> :t xor
xor :: Bool -> Bool -> Bool
*Main> 
</pre>
</p>
<p>
もうちょっと現実的っぽい例を．GUI で使うような，ウィンドウ開くやつ．<br />
ちょっと簡略化してるけどイメージ的には
<pre style="background:#000;color:#f8f8f8">
<span style="color:#89bdff">openWindow</span> <span style="color:#e28964">::</span> <span style="color:#99cf50">WindowTitle</span> <span style="color:#e28964">-></span> <span style="color:#99cf50">WindowSize</span> <span style="color:#e28964">-></span> <span style="color:#99cf50">Window</span>
</pre>
ね，分かりやすそうやん．とりあえずこれからも <code>:t</code> は常に使って行きましょう．
</p>
<p>
練習問題．それぞれ型はどうかけるでしょう．
<ol>
<li>関数 <code>negate</code>, Int を受け取ってその符号を逆にしたのを返す．<code>negate 3 = -3, negate -3 = 3</code> など．</li>
<li>関数 <code>(||)</code>. </li>
<li><code>monthLength</code>. うるう年かどうかの Bool と月を表す Int からその月の日の数を返す．</li>
<li><code>f x y = not x && y</code></li>
<li><code>g x = (2*x - 1)ˆ2</code>. 数は Int.</li>
</ol>
</p>

<h3> Type Inference</h3>
<p>
type signature を僕らが書かなくても ghci とか ghc はわかってくれる，のは，<br />
type inference, 型推論ってのをやってくれるから．流れはこんな感じ．
<pre style="background:#000;color:#f8f8f8">
isL c <span style="color:#e28964">=</span> c <span style="color:#e28964">==</span> <span style="color:#65b042">'l'</span>
</pre>
type signature 無しに書いてみる．ちゃんとこれでも
<pre style="background:#000;color:#f8f8f8">
:t isL
isL :: Char -> Bool
</pre>
とわかってくれてるわけ．<br />
<ul>
<li>まず 'l' は Char.</li>
<li>となるとそれと <code>(==)</code> で比べられるためには c は Char じゃないとね</li>
<li>最後に帰ってくるのは Bool だよね</li>
</ul>
って感じですね．<br />
とはいえコードの読みやすさとか，バグ取りのこととか考えると type signature は積極的にしていこう．<br />
たとえば typo とかしても， type signature をしといたら弾けることも多いけど，<br />
signature なかったらそのまま変な型推論して妙なところで error でるかもしれないよね．<br />
それに関数名と type signature 見たらだいたい何するかわかったりもするし．<br />
このへんの事のおかげで，Haskell では「コンパイルは通ったけど動かしてみたら変な感じ」ってことは少なくて，<br />
コンパイルの段階で「なんか変ﾀﾞﾖｰ」ってなって，コンパイルさえ通ればまあちゃんと動くぜって感じみたい． すごい．
</p>
<h2> Lists and tuples </h2>
list と tuple のお話．
<h3> Lists </h3>
<p>
list の書き方：
<pre style="background:#000;color:#f8f8f8">
numbers <span style="color:#e28964">=</span> [<span style="color:#3387cc">1</span>,<span style="color:#3387cc">2</span>,<span style="color:#3387cc">3</span>,<span style="color:#3387cc">86</span>]
strings <span style="color:#e28964">=</span> [<span style="color:#65b042">"here"</span>, <span style="color:#65b042">"are"</span>, <span style="color:#65b042">"some"</span>, <span style="color:#65b042">"strings"</span>]
bools <span style="color:#e28964">=</span> [<span style="color:#cf6a4c">True</span>, <span style="color:#cf6a4c">False</span>, <span style="color:#cf6a4c">True</span>, <span style="color:#cf6a4c">False</span>]
</pre>
<ul>
<li>同じ type のものだけを集められます（異なる type をまとめようとすると type error:
<pre style="background:#000;color:#f8f8f8">
Prelude> let thisdoesntwork = [2, 'a']

&lt;interactive>:5:23:
    No instance for (Num Char) arising from the literal `2'
    Possible fix: add an instance declaration for (Num Char)
    In the expression: 2
    In the expression: [2, 'a']
    In an equation for `thisdoesntwork': thisdoesntwork = [2, 'a']
</pre></li>
<li> <code>(足すもの):(list)</code>という記法で要素を足した list を手に入れることができます(このことを cons (<i>verb</i>) というらしい)．この時の evaluation は右から左に行われ，好きなだけつなげて行けます．
<pre style="background:#000;color:#f8f8f8">
Prelude> let numbers = [1,2,3,1,4]
Prelude> 1:numbers
[1,1,2,3,1,4]
Prelude> 1:0:4:numbers
[1,0,4,1,2,3,1,4]
Prelude> numbers:numbers

&lt;interactive>:5:9:
    Couldn't match type `Integer' with `[Integer]'
    Expected type: [[Integer]]
      Actual type: [Integer]
    In the second argument of `(:)', namely `numbers'
    In the expression: numbers : numbers
    In an equation for `it': it = numbers : numbers
</pre>
っていう感じ．
<ul>
<li>ほんま言うと <code>[1,2,3]</code> っていうの自体も <code>1:2:3:[]</code> の syntax sugar. 最後の <code>[]</code> 忘れないように．</li>
<li><code>(:)</code> も例によって関数．
<pre style="background:#000;color:#f8f8f8">
Prelude> :t (:)
(:) :: a -> [a] -> [a]
</pre>
<li>前言った通り String は Char の list なので，
<pre style="background:#000;color:#f8f8f8">
Prelude> 't':"here"
"there"
Prelude> "me" == ['m','e']
True
</pre>
</ul></li>
<li>あれ，それなら <code>[]</code> の type ってなんなんだろう．
<pre style="background:#000;color:#f8f8f8">
Prelude> :t []
[] :: [a]
</pre>
Haskell 「なんかわからんけどなんかのリストや」<br />
なるほど．</li>
<li>型さえ揃ってれば何でもいいので，（型が同じ） list の list も作れます．
<pre style="background:#000;color:#f8f8f8">
listOfLists <span style="color:#e28964">=</span> [ [<span style="color:#3387cc">1</span>,<span style="color:#3387cc">2</span>], [<span style="color:#3387cc">3</span>,<span style="color:#3387cc">4</span>], [<span style="color:#3387cc">5</span>,<span style="color:#3387cc">6</span>,<span style="color:#3387cc">7</span>]]
anotherList <span style="color:#e28964">=</span> <span style="color:#3387cc">[]</span><span style="color:#e28964">:</span>[<span style="color:#3387cc">1</span>]<span style="color:#e28964">:</span><span style="color:#3387cc">[]</span><span style="color:#e28964">:</span><span style="color:#3387cc">[]</span>
</pre>
でもこんなのはだめよ
<pre style="background:#000;color:#f8f8f8">
lol  <span style="color:#e28964">=</span> [ <span style="color:#3387cc">1</span>, [<span style="color:#3387cc">1</span>,<span style="color:#3387cc">2</span>]]
lol2 <span style="color:#e28964">=</span> [ [<span style="color:#65b042">'a'</span>], [<span style="color:#3387cc">2</span>] ]
</pre>
</ul> 
</p>
<p>
練習問題．はまあ省略でいいわ．
</p>
<h3> Tuples </h3>
<p>
Tuples の書き方：
<pre style="background:#000;color:#f8f8f8">
tuple1 <span style="color:#e28964">=</span> (<span style="color:#3387cc">1</span>,<span style="color:#3387cc">3.3</span>)
tuple2 <span style="color:#e28964">=</span> (<span style="color:#cf6a4c">True</span>, <span style="color:#3387cc">3</span>)
tuple3 <span style="color:#e28964">=</span> (<span style="color:#3387cc">4</span>, <span style="color:#3387cc">5</span>, <span style="color:#65b042">"Six"</span>, <span style="color:#cf6a4c">True</span>, <span style="color:#65b042">'b'</span>)
tuple4 <span style="color:#e28964">=</span> ((<span style="color:#3387cc">2</span>,<span style="color:#3387cc">3</span>), [<span style="color:#3387cc">2</span>,<span style="color:#3387cc">3</span>])
</pre>
Tuple は
<ul>
<li>要素の数は変更できない (immutable). <code>(:)</code> で cons することも従ってできない．
<ul><li>だから座標を表すのとかにいいかも．</li>
<li>要素の数 n に対して一般には n-tuple. 2 の時は pair, 3の時は triple ということが多い．一応それ以降は quadruples, quintuples と続く．tuple の名はここから．</ul>
</li>
<li>要素の型がそろってなくてもいい．
<ul><li>電話帳とかにいいかも．</li></ul></li>
</ul></p>
<p>
補足事項
<ul>
<li>関数のとる値とかがこれになるようにしとくと複数の値を返す相当だぜ</li>
<li>マスターいつもの
<pre style="background:#000;color:#f8f8f8">
Prelude> :t ('a', True)
('a', True) :: (Char, Bool)
Prelude> :t ()
() :: ()
</pre>
前者からわかるとおり，<code>('a', True)</code> と <code>(True, 'a')</code> は type が別になるので注意．
</li>
</ul>
</p>
<p>
というわけで tuple と list をそれぞれ入れ子にしたりできる．
<pre style="background:#000;color:#f8f8f8">
((<span style="color:#3387cc">2</span>,<span style="color:#3387cc">3</span>), <span style="color:#cf6a4c">True</span>)
((<span style="color:#3387cc">2</span>,<span style="color:#3387cc">3</span>), [<span style="color:#3387cc">2</span>,<span style="color:#3387cc">3</span>])
[(<span style="color:#3387cc">1</span>,<span style="color:#3387cc">2</span>), (<span style="color:#3387cc">3</span>,<span style="color:#3387cc">4</span>), (<span style="color:#3387cc">5</span>,<span style="color:#3387cc">6</span>)]
</pre>
たとえば
<pre style="background:#000;color:#f8f8f8">
[(<span style="color:#3387cc">1</span>,<span style="color:#3387cc">2</span>),(<span style="color:#3387cc">3</span>,<span style="color:#3387cc">4</span>,<span style="color:#3387cc">5</span>)]
</pre>
は通りませんで．
</p>
<h3> Retrieving Values </h3>
<p>
list とか tuple 作ったんだからそこから要素引き出したいぜ！<br />
っていう話なんやけど，ちょっと準備の必要な話でもあるので，まずは単純なやつだけ．<br />
いずれにしても割と気持ち悪いぜ！
<ul>
<li>list. <code>head</code> がリストの頭を，<code>tail</code> がそれ以降の部分を返す．正確にいうならそういう写像．<br />
これ，<code>(:)</code> で繋いだのの端っこを切ることでできている．
<pre style="background:#000;color:#f8f8f8">
Prelude> head [2,5,3,6]
2
Prelude> tail [2,5,3,6]
[5,3,6]
Prelude> head (2:5:3:6:[])
2
Prelude> head "there"
't'
Prelude> tail "there"
"here"
Prelude> tail "t"
""
Prelude> tail [1]
[]
Prelude> tail []
*** Exception: Prelude.tail: empty list
Prelude> head []
*** Exception: Prelude.head: empty list
</pre>
<code>tail [1]</code> が <code>[]</code> になるのは <code>[1]</code> が <code>1:[]</code> だから，かな． </li>
<li>pair (要素2つの tuple) : <code>fst</code> で 1つめの要素を，<code>snd</code> で 2つめの要素を取得．
<pre style="background:#000;color:#f8f8f8">
Prelude> fst (2,5)
2
Prelude> fst (True,"noo")
True
Prelude> fst( snd ( (True, 3), (2,"there")))
2
Prelude> fst (2,3,1)

&lt;interactive>:5:5:
    Couldn't match expected type `(a0, b0)'
                with actual type `(t0, t1, t2)'
    In the first argument of `fst', namely `(2, 3, 1)'
    In the expression: fst (2, 3, 1)
    In an equation for `it': it = fst (2, 3, 1)
</pre>
pair にしかこれは使えないんだ，すまない．（<code>(2,3)</code> と <code>(2,3,4)</code> では type が違うからね）
</li>
</ul>
</p>
<p>練習問題．
<ol>
<li><code>( ("Hello", 4), True)</code> から 4 を取り出してみよう．</li>
<li>tuple で list の 頭と残りを返す関数書いてみよう．</li>
<li><code>head</code> と <code>tail</code> で list の 5番目の要素を返す関数を書いてみよう．どこかどう面倒くさいか考えておこう．
</ol>
</p>
<h3> polymorphic types </h3>
<p>
さて，
<pre style="background:#000;color:#f8f8f8">
[<span style="color:#cf6a4c">True</span>, <span style="color:#cf6a4c">False</span>, <span style="color:#cf6a4c">True</span>]
[<span style="color:#65b042">'a'</span>, <span style="color:#65b042">'b'</span>]
[<span style="color:#65b042">"hey"</span>, <span style="color:#65b042">"may"</span>]
</pre>
それぞれ型が違います．最初のは <code>[Bool]</code>, 続いて <code>[Char]</code>, さらに <code>[[Char]]</code>.<br />
ほんで，これまでやってきた通り，関数が受け取れる型っていうのは予め決まってるわけ． <br />
と，いうことは．例えば list の長さが欲しい時には，<br />
<code>lengthBools :: [Bool] -> Int</code> とか <code>lengthChars :: [Char] -> Int</code> とか色々必要，<br />
というのはあまりに面倒というか理不尽．実際にはひとつの関数 <code>length</code> が対応してくれるのでこれの型を見てみましょう．
<pre style="background:#000;color:#f8f8f8">
Prelude> :t length
length :: [a] -> Int
</pre>
この <code>a</code> っていうのは型じゃない（そもそも型は大文字から始まる）．<br />
これが type variable, 型変数と呼ばれるもので，ここにはどんな型でも入ってよい．<br />
つまるところこの <code>[a]</code> という型表示は，<code>Bool</code> <code>[[Char]]</code> その他，何でもいいからそれのリスト，ってこと．
こういうふうに複数の型を（同時にではないが）許容するのは type theory の用語で polymorphism というらしい．<br />
形容詞系は polymorphic, 対義語は monomorphic.<br />
ここで気をつけるべきは，ひとつの type signature の中では同じ型変数には同じ型が入るということ．<br />
ふつうの変数と同じですね．例えば，
<pre style="background:#000;color:#f8f8f8">
<span style="color:#89bdff">f</span> <span style="color:#e28964">::</span> <span style="color:#3e87e3">a</span> <span style="color:#e28964">-></span> <span style="color:#3e87e3">a</span>
</pre>
という時にはなんの型でもいいから受け取って同じ型で返す関数を表わしてて，
<pre style="background:#000;color:#f8f8f8">
<span style="color:#89bdff">f</span> <span style="color:#e28964">::</span> <span style="color:#3e87e3">a</span> <span style="color:#e28964">-></span> <span style="color:#3e87e3">b</span>
</pre>
という時には <code>a</code> と <code>b</code> は同じかもしれないし違うかもしれない．
</p>
<p>
というわけで早速具体例を見てみよう．そろそろ何を見ても「型はどうなってるかな」と気になる頃．
さっきやった <code>fst</code> と <code>snd</code> はどうなるだろうか（もちろんまず自分で考えて）．
<pre style="background:#000;color:#f8f8f8">
Prelude> :t fst
fst :: (a, b) -> a
Prelude> :t snd
snd :: (a, b) -> b
</pre>
すっきり．<code>head</code> と <code>tail</code> とかも各自．
</p>
<p>
練習問題
<ol>
<li>前の
<ol>
<li><code>( ("Hello", 4), True)</code> から 4 を取り出してみよう．</li>
<li>tuple で list の 頭と残りを返す関数書いてみよう．</li>
</ol>の型</li>
<li><code>h x y z = chr (x-2)</code> の型は？ (試すときは<code>:m</code> か <code>import</code> 忘れずに）</li>
</ol>
</p>
<p>
練習問題のあれ
<pre style="background:#000;color:#f8f8f8">
Prelude> :m Data.Char
Prelude Data.Char> let h x y z =  chr (x-2)
Prelude Data.Char> :t h
h :: Int -> t -> t1 -> Char
</pre>
この <code>t</code> とか <code>t1</code> とかでどのアルファベットを選ぶかってなんか決まりあるんだろうか．
</p>
<h2> Type Basics II </h2>
<h3> Typeclass </h3>
<p>
さてさて，これまでぼんやりとしか喋ってこなかったけれども，例えば <code>(+)</code> の type はどうあるべきか．<br />
アレやん， <code>Int</code> 同士の足し算ならいいけどさ， <code>Float</code> とかも自在に扱って欲しいわけ．<br />
かといって <code>Char</code> と <code>Int</code> を勝手に足されても困る．<br />
たとえば <code>Number</code> みたいな型があって，それで数全部を扱ってしまえれば嬉しい：
<pre style="background:#000;color:#f8f8f8">
<span style="color:#89bdff">(+)</span> <span style="color:#e28964">::</span> <span style="color:#99cf50">Number</span> <span style="color:#e28964">-></span> <span style="color:#99cf50">Number</span> <span style="color:#e28964">-></span> <span style="color:#99cf50">Number</span>
</pre>
せやけど，例えば浮動小数点型と整数型は区別せな色々困るわけで，これはやっぱり望み薄．<br />
先程の type variable の概念を援用し，たいところだが，そのままだと数以外のものの足し算も許容してしまう．<br />
というわけで… clever にも，「数を表す型ならなんでもおｋ」な型変数みたいな指定ができるのです！
<pre style="background:#000;color:#f8f8f8">
<span style="color:#89bdff">(+)</span> <span style="color:#e28964">::</span> (<span style="color:#9b5c2e;font-style:italic">Num</span> <span style="color:#3e87e3">a</span>) <span style="color:#e28964">=></span> <span style="color:#3e87e3">a</span> <span style="color:#e28964">-></span> <span style="color:#3e87e3">a</span> <span style="color:#e28964">-></span> <span style="color:#3e87e3">a</span>
</pre>
この <code>Num</code> っていうのが typeclass と言われるもので，<code>Num a =></code> の部分で制約をかけているわけ．<br />
かっこ良くいうと <code>a</code> を <code>Num</code> の instance に制限する，ということらしい．
</p>
<h3>Numeric Types</h3>
<p>というわけで数を表す型にどんなものがあるか．
<ul>
<li><code>Int</code>. 精度の固定されてるよくある整数型．少なくとも <code>[-2^29 .. 2^29-1]</code> を扱えるらしい．</li>
<li><code>Integer</code>. 任意精度の整数（メモリのある限り数え続けてくれる）．python でいう Long Integer.</li>
<li><code>Float</code>. 単精度浮動小数点型．特段事情がなければ <code>Double</code> 使いましょう．</li>
<li><code>Double</code>. 倍精度浮動小数点型．小数というか実数扱うならだいたいこれのお世話になる．</li>
</ul>
</p>
<p>この光のもとで足し算とかそのへんを見なおしてみる． <br />
先ほど申し上げた通り，
<pre style="background:#000;color:#f8f8f8">
<span style="color:#89bdff">(+)</span> <span style="color:#e28964">::</span> (<span style="color:#9b5c2e;font-style:italic">Num</span> <span style="color:#3e87e3">a</span>) <span style="color:#e28964">=></span> <span style="color:#3e87e3">a</span> <span style="color:#e28964">-></span> <span style="color:#3e87e3">a</span> <span style="color:#e28964">-></span> <span style="color:#3e87e3">a</span>
</pre>
というわけですが，では例えば
<pre style="background:#000;color:#f8f8f8">
<span style="color:#3387cc">3</span> <span style="color:#e28964">+</span> <span style="color:#3387cc">2.5</span>
</pre>
これ整数 (<code>Int</code> とか <code>Integer</code> とか) と
非整数 (<code>Float</code> or <code>Double</code>) の足し算にみえるけど．<br />
でも2つの型が違うと困る．上の <code>a -> a -> a</code> が困る．<br />
実は：
<pre style="background:#000;color:#f8f8f8">
Prelude> :t 3
3 :: Num a => a
</pre>
3 自体はまだ <code>Int</code> でも <code>Integer</code> でも <code>Double</code> でも無いわけですねー．
じゃあ 2.5 はっと
<pre style="background:#000;color:#f8f8f8">
Prelude> :t 2.5
2.5 :: Fractional a => a
</pre>
ほみほみ．なんか <code>Real</code> とか <code>Eq</code> とか色々あるみたいやけど，今は深入りはやめとこう．<br >
少なくとも <code>Fractional</code> は <code>Num</code> で，
<code>Int</code> や <code>Integral</code> は <code>Fractional</code> じゃないです． <br />
Haskell さんの解釈としては，まず制約のきつい <code>2.5</code> の方を考えて，<br />
特に他に情報はないのでデフォルトの <code>Double</code> として処理し，その後全体によきにはからう．<br />
結局（この場合）計算全体は <code>Double</code> で進行して <code>Double</code> で帰ってくる．<br />
これ，型キャストとも雰囲気が似ているが，Haskell では明示的に polymorphic なものにしか行われない．<br />
</p>
<!--
<p>たとえば<br />
<code>foo.hs</code> （前にも出てきたとか気にしない）
<pre style="background:#000;color:#f8f8f8">
x <span style="color:#e28964">=</span> <span style="color:#3387cc">2</span>
</pre>
ここから ghci で
<pre style="background:#000;color:#f8f8f8">
Prelude> :l foo.hs 
[1 of 1] Compiling Main             ( foo.hs, interpreted )
Ok, modules loaded: Main.
*Main> :t x
x :: Integer
</pre>
>>>突然の Integer <<<
でちょっとこまる
-->
<p>
さてさて．
<pre style="background:#000;color:#f8f8f8">
<span style="color:#3387cc">Prelude</span><span style="color:#e28964">></span> <span style="color:#e28964">:</span>t <span style="color:#89bdff">(/)</span>
<span style="color:#89bdff">(/)</span> <span style="color:#e28964">::</span> <span style="color:#99cf50">Fractional</span> <span style="color:#3e87e3">a</span> <span style="color:#e28964">=></span> <span style="color:#3e87e3">a</span> <span style="color:#e28964">-></span> <span style="color:#3e87e3">a</span> <span style="color:#e28964">-></span> <span style="color:#3e87e3">a</span> 
</pre>
<code>Fractional</code> への制限は，python2.x みたいに <code>3/2</code> が <code>1</code> にはなってほしくないので必要だけど，<br />
たとえばはっきり <code>Int</code> やでって宣言してるような奴
<pre style="background:#000;color:#f8f8f8">
<span style="color:#3387cc">Prelude</span><span style="color:#e28964">></span> <span style="color:#e28964">:</span>t <span style="color:#dad085">length</span> 
<span style="color:#89bdff">length</span> <span style="color:#e28964">::</span> [<span style="color:#3e87e3">a</span>] <span style="color:#e28964">-></span> <span style="color:#9b859d">Int</span>
</pre>
とかでやろうとしてみると
<pre style="background:#000;color:#f8f8f8">
Prelude> 4 / length [1,2]

&lt;interactive>:2:3:
    No instance for (Fractional Int) arising from a use of `/'
    Possible fix: add an instance declaration for (Fractional Int)
    In the expression: 4 / length [1, 2]
    In an equation for `it': it = 4 / length [1, 2]
</pre>
polymorphism が型キャストと違うというのはこういうところ．<br />
なおこの場合は便利な関数があって，
<pre style="background:#000;color:#f8f8f8">
<span style="color:#89bdff">fromIntegral</span> <span style="color:#e28964">::</span> (<span style="color:#99cf50">Integral</span> <span style="color:#3e87e3">a</span>, <span style="color:#99cf50">Num</span> <span style="color:#3e87e3">b</span>) <span style="color:#e28964">=></span> <span style="color:#3e87e3">a</span> <span style="color:#e28964">-></span> <span style="color:#3e87e3">b</span>
</pre>
見ての通り．
<pre style="background:#000;color:#f8f8f8">
Prelude> 4 / fromIntegral(length [1,2])
2.0
Prelude> 4 / fromIntegral(length [1,2,3])
1.3333333333333333
</pre>
めでたし．かな．
</p>
<p>ついでに補足．
<pre style="background:#000;color:#f8f8f8">
<span style="color:#89bdff">(==)</span> <span style="color:#e28964">::</span> (<span style="color:#9b5c2e;font-style:italic">Eq</span> <span style="color:#3e87e3">a</span>) <span style="color:#e28964">=></span> <span style="color:#3e87e3">a</span> <span style="color:#e28964">-></span> <span style="color:#3e87e3">a</span> <span style="color:#e28964">-></span> <span style="color:#9b859d">Bool</span>
</pre>
この <code>Eq</code> は正味比較して等しいかどうかを判断できるもの，みたいなアレ．non-functional なのはだいたいこれらしい．<br /> 
typeclass のもっとすごい力とか，カスタマイズの仕方とかは，後々出てくるのでお待ちください．
<h2> Building Vocabulary </h2>
<h3> Function composition </h3>
<p> 
関数の合成というかなんというか．普通に g(f(x)) な感じでよろしい．
<pre style="background:#000;color:#f8f8f8">
f x <span style="color:#e28964">=</span> x <span style="color:#e28964">+</span> <span style="color:#3387cc">3</span>
square x <span style="color:#e28964">=</span> x * x
</pre>
で
<pre style="background:#000;color:#f8f8f8">
Prelude> square(f 1)
16
Prelude> square(f 2)
25
Prelude> f (square 1)
4
Prelude> f (square 4)
19
</pre>
という感じ．
<pre style="background:#000;color:#f8f8f8">
g x <span style="color:#e28964">=</span> f (square x)
</pre>
みたいな書き方もできます．<br />
これ，括弧がないと <code>f square</code> を計算しようとして上手く行きません．<br />
関数の合成には特別な書き方もあります： 数学で関数の合成の時に使う記号を模した<code>(.)</code> を使って
<pre style="background:#000;color:#f8f8f8">
g x <span style="color:#e28964">=</span> (f <span style="color:#e28964">.</span> square) x
</pre>
そしてこれは
<pre style="background:#000;color:#f8f8f8">
g  <span style="color:#e28964">=</span> f <span style="color:#e28964">.</span> square
</pre>
と書いても動くがどちらが推奨されてるのかは知らない．
</p>

<h3> The need for a vocabulary </h3>
<p>
さてこうして関数の合成もできるようになり，あと再帰でもやれば色々書けるようになる，のだが，<br />
その際には Haskell の standard libraries に何があるのかをある程度知っていることは，<br />
コードの効率とか読みやすさ書きやすさ上結構重要になってきます．<br />
<small>standard libraries にある関数を自分で書き直すのももちろん勉強になるけどね．</small><br />
というわけで，そのへんのこと，どう調べたらいいか，とかのお話．
</p>

<h3> Prelude and the hierarchical libraries </h3>
<p>
とうとう来ました．ghci を起動するときに出てくるアレ．
<pre style="background:#000;color:#f8f8f8">
Prelude> 
</pre>
この <code>Prelude</code> はすべての Haskell プログラムでデフォルトで読み込まれる core library.  <br />
これまで扱ったようなごく基本的な関数や，<code>map</code> とか <code>filter</code> みたいなもうちょっと高級な（？）ものなど．<br />
そしてデフォルトでは読み込まれずに <code>import</code> (ghci からは <code>:module</code>) する必要のある module たち，<br />
hierarchical libraries がある．<br />
例えば <code>permutations</code> という関数が <code>Data.List</code> にあって，これを使うときはソースで
<pre style="background:#000;color:#f8f8f8">
<span style="color:#e28964">import</span> <span style="color:#9b859d">Data.List</span>
testPermitations <span style="color:#e28964">=</span> permutations <span style="color:#65b042">"Prelude"</span>
</pre>
ghci から読み込む場合は，前にも書いた通り
<pre style="background:#000;color:#f8f8f8">
Prelude> :m Data.List
</pre>
複数読み込む（読み込まれる module を追加していく）時は
<pre style="background:#000;color:#f8f8f8">
Prelude> :m +Data.List
</pre>
と <code>+</code> を使う．<br />
折角だから使ってみましょう
<pre style="background:#000;color:#f8f8f8">
Prelude> :m +Data.List 
Prelude Data.List> :t permutations 
permutations :: [a] -> [[a]]
Prelude Data.List> permutations "sll"
["sll","lsl","lls","lls","lsl","sll"]
</pre>
つまるところこの <code>></code> の左側にあるのは現在読み込まれてるライブラリ，という感じ．
</p>
<h3> One exhibit </h3>
<p>
便利なライブラリをちゃんと使おう，な話．<br />
関数：単語がスペースで区切られた文字列を受け取って単語を逆順に並べたのを返す．<br />
the quick brown fox なら fox brown quick the になるもの．
python なら
<pre style="background:#000;color:#f8f8f8">
<span style="color:#99cf50">def</span> <span style="color:#89bdff">rev_words</span>(<span style="color:#3e87e3">text</span>):
    words <span style="color:#e28964">=</span> text.split()
    words.reverse()
    <span style="color:#e28964">return</span> <span style="color:#65b042">" "</span>.join(words)
</pre>
Haskell の <code>Prelude</code> にはこんな関数たちがいるのだ！
<ul>
<li><code>words</code>, (Tab とかもアリで）空白で区切られた単語を含む文字列を単語のリストにして返す</li>
<li><code>reverse</code> list を reverse する</li>
<li><code>unwords</code> words の反対．</li>
</ul>
でこれを使えば
<pre style="background:#000;color:#f8f8f8">
<span style="color:#89bdff">revWords</span> <span style="color:#e28964">::</span> <span style="color:#9b859d">String</span> <span style="color:#e28964">-></span> <span style="color:#9b859d">String</span>
revWords input <span style="color:#e28964">=</span> (<span style="color:#dad085">unwords</span><span style="color:#e28964">.</span> <span style="color:#dad085">reverse</span><span style="color:#e28964">.</span> <span style="color:#dad085">words</span>) input
</pre>
いい感じでかけます．
一方，上の便利な関数を使わず，これまでやってきたこと + ちょっと，だけ使うならこう書ける（ '''ヤバ''' い）．
<pre style="background:#000;color:#f8f8f8">
<span style="color:#89bdff">monsterRevWords</span> <span style="color:#e28964">::</span> <span style="color:#9b859d">String</span> <span style="color:#e28964">-></span> <span style="color:#9b859d">String</span>
monsterRevWords input <span style="color:#e28964">=</span> rejoinUnreversed (divideReversed input)
    <span style="color:#e28964">where</span>
    divideReversed s <span style="color:#e28964">=</span> go1 <span style="color:#3387cc">[]</span> s
        <span style="color:#e28964">where</span>
        go1 divided <span style="color:#3387cc">[]</span> <span style="color:#e28964">=</span> divided
        go1 <span style="color:#3387cc">[]</span> (c<span style="color:#e28964">:</span>cs)
            <span style="color:#e28964">|</span> testSpace c <span style="color:#e28964">=</span> go1 <span style="color:#3387cc">[]</span> cs
            <span style="color:#e28964">|</span> <span style="color:#dad085">otherwise</span>   <span style="color:#e28964">=</span> go1 [<span style="color:#3387cc">[]</span>] (c<span style="color:#e28964">:</span>cs)
        go1 (w<span style="color:#e28964">:</span>ws) [c]
            <span style="color:#e28964">|</span> testSpace c <span style="color:#e28964">=</span> (w<span style="color:#e28964">:</span>ws)
            <span style="color:#e28964">|</span> <span style="color:#dad085">otherwise</span>   <span style="color:#e28964">=</span> ((c<span style="color:#e28964">:</span>w)<span style="color:#e28964">:</span>ws)
        go1 (w<span style="color:#e28964">:</span>ws) (c<span style="color:#e28964">:</span>c'<span style="color:#e28964">:</span>cs)
            <span style="color:#e28964">|</span> testSpace c <span style="color:#e28964">=</span>
                <span style="color:#e28964">if</span> testSpace c'
                    <span style="color:#e28964">then</span> go1 (w<span style="color:#e28964">:</span>ws) (c'<span style="color:#e28964">:</span>cs)
                    <span style="color:#e28964">else</span> go1 ([c']<span style="color:#e28964">:</span>w<span style="color:#e28964">:</span>ws) cs
            <span style="color:#e28964">|</span> <span style="color:#dad085">otherwise</span> <span style="color:#e28964">=</span>
                <span style="color:#e28964">if</span> testSpace c'
                    <span style="color:#e28964">then</span> go1 ((c<span style="color:#e28964">:</span>w)<span style="color:#e28964">:</span>ws) (c'<span style="color:#e28964">:</span>cs)
                    <span style="color:#e28964">else</span> go1 ((c<span style="color:#e28964">:</span>w)<span style="color:#e28964">:</span>ws) (c'<span style="color:#e28964">:</span>cs)
    testSpace c <span style="color:#e28964">=</span> c <span style="color:#e28964">==</span> <span style="color:#65b042">' '</span>
    rejoinUnreversed <span style="color:#3387cc">[]</span> <span style="color:#e28964">=</span> <span style="color:#3387cc">[]</span>
    rejoinUnreversed [w] <span style="color:#e28964">=</span> reverseList w
    rejoinUnreversed strings <span style="color:#e28964">=</span> go2 (<span style="color:#65b042">' '</span> <span style="color:#e28964">:</span> reverseList newFirstWord) (otherWords)
        <span style="color:#e28964">where</span>
        revStrings <span style="color:#e28964">=</span> reverseList strings
        newFirstWord <span style="color:#e28964">=</span> <span style="color:#dad085">head</span> revStrings
        otherWords <span style="color:#e28964">=</span> <span style="color:#dad085">tail</span> revStrings
        go2 rejoined (<span style="color:#3387cc">[]</span><span style="color:#e28964">:</span><span style="color:#3387cc">[]</span>) <span style="color:#e28964">=</span> rejoined
        go2 rejoined (<span style="color:#3387cc">[]</span><span style="color:#e28964">:</span>(w'<span style="color:#e28964">:</span>ws')) <span style="color:#e28964">=</span> go2 (rejoined) ((<span style="color:#65b042">' '</span><span style="color:#e28964">:</span>w')<span style="color:#e28964">:</span>ws')
        go2 rejoined ((c<span style="color:#e28964">:</span>cs)<span style="color:#e28964">:</span>ws) <span style="color:#e28964">=</span> go2 (c<span style="color:#e28964">:</span>rejoined) (cs<span style="color:#e28964">:</span>ws)
    reverseList <span style="color:#3387cc">[]</span> <span style="color:#e28964">=</span> <span style="color:#3387cc">[]</span>
    reverseList w <span style="color:#e28964">=</span> go3 <span style="color:#3387cc">[]</span> w
        <span style="color:#e28964">where</span>
        go3 rev <span style="color:#3387cc">[]</span> <span style="color:#e28964">=</span> rev
        go3 rev (c<span style="color:#e28964">:</span>cs) <span style="color:#e28964">=</span> go3 (c<span style="color:#e28964">:</span>rev) cs
</pre>
もちろん初学者たる我々にとっては読めば勉強になるだろうけれど，基本的には読む気にならないし，アレ．<br />
そもそもこれでほんとにちゃんと動くのか確信持てないしちょっと書き換えるのも大変そう．<br />
さらにここで
<pre style="background:#000;color:#f8f8f8">
testSpace c <span style="color:#e28964">=</span> c <span style="color:#e28964">==</span> <span style="color:#65b042">' '</span>
</pre>
とある通り，この場合単語を区切るのは半角スペースじゃないといけない (tab や 改行コードはだめ）．<br />
など，まあこれを使いたくはない．<small>なお <code>Data.Char</code> にある <code>isSpace</code> を使えばそのへん含めて空白か判定できる．らしい．</code><br />
と，まあ色々 ''ヤバ'' いので，しっかり使える道具は使いましょう，というおはなし．
</p>
<h3> Acquiring vocabulary </h3>

