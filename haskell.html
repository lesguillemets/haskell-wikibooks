<meta charset="utf-8">
en.wikibooks の <a href="http://en.wikibooks/org/wiki/Haskell">Haskell</a> をベースに．<br />
wikibooks のライセンスを継承して CC-BY-SA です．
<h2>Getting set up</h2>
<p>
まずは haskell のインストール． Glasgow Haskell Compiler, GHC がおすすめ．<br />
ちなみにこの GHC自体も Haskell で書かれてるらしい<small>（だからソースから自分でビルドしようとするとめっちゃ苦労するらしい）</small>．<br />
ubuntu とかなら
<code Plain Text>
$ sudo apt-get update
$ sudo apt-get install ghc
</code>
でよい． コンパイラとともに GHCi (i for <i>interacitve</i>)という interactive environment がついてきます．<br />
若干 python とかのインタープリタとは趣が違うんやけど，まあともかくこの人とお話していきましょう．<br />
linux ならたとえば
<code Plain Text>
$ ghci
GHCi, version 7.6.2: http://www.haskell.org/ghc/  :? for help
Loading package ghc-prim ... linking ... done.
Loading package integer-gmp ... linking ... done.
Loading package base ... linking ... done.
Prelude> 
</code>
というかんじ．<small>かっこいいアスキーアートが出てくる例が多いみたいやけどなんか僕の環境では出てきません． </small><br />
ここで <code> loading package </code>とかやってくれてますが，<br />
これによって built-in functions や modules にはだいたいアクセスできる．<br />
<code>Prelude></code> は prompt ってやつで，ここにコマンドを書き込んでいく．<small>prelude の意味はそのうち出てくるはず．</small><br />
</p>
<p>
というわけで四則とかそのへん．まだすごくない．
<code Plain Text>
Prelude> 2+2
4
Prelude> 5 * 4 + 3 
23
Prelude> 2^5
32
</code>
指数は <code>^</code>で書くぜってあたり以外は特記事項なし．<br />
...と思ってたら， <code>^</code> は <code>(Integral b, Num a) => a -> b -> a </code>. <br />
<small>（この記法の意味はしばらく先に出てきます．とりあえずは数なものと Integral なもの（こっちが第2引数）を受け取って数を返す（数学で言う）函数ってこと．）</small><br />
例えば
<code Plain Text>
Prelude> 2^1.2
</code>
はエラーを，
<code Plain Text>
Prelude> 2^(-1)
</code>
は Exception を返してくるみたい．<br />
こういうのも含めて指数を書くときは <code> ** </code> で．
<code Plain Text>
Prelude> :t (**)
(**) :: Floating a => a -> a -> a
</code>
まとめると
<code Plain Text>
Prelude> 2**(-1)
0.5
Prelude> 2**0.5
1.4142135623730951
Prelude> 1.0^2
1.0
</code>
これからお世話になる ghci はソースファイル読み込んだりとかもちゃんとできる優秀なひと，らしい．
</p>

<p><h2>Variables and functions</h2>
さっきのは単にその場所で計算しっぱなしやったけど，これは不便よね．<br />
というわけでそういうのは value をもつ variable に保存されます．例えば半径5の円の面積
<code Plain Text>
ghci>3.1416 * 5^2
78.53999999999999
</code>
<small>#これ<code>ghci></code>ってなってるけどたとえば <code>Prelude></code> でやっていい．</small><br />
やけど，いちいち打ち込むのはあんまりです．<br />
この場合すでに pi っていう variable が define されてて，
<code Plain Text>
ghci> pi
3.141592653589793
ghci> pi * 5^2
78.53981633974483
</code>
善哉．<br />
この辺りで最後に表示されるのは結局，式とか函数を評価していって最後に値がひとつ残った時にそれを表示，ということが行われてます．<br />
なお Haskell に変数はない，という言い方も多い（値を "束縛" することはあっても，それを変化させられないから）けど，<br /> 
ここではとりあえず variable と呼んでおきます．なんかもう全部（数学で言う）関数みたいなもん，みたい．
</p>
<h3>Haskell source files</h3>
<p>ではでは僕らも変数を定義してみよう．と，いうところで…
<code Plain Text>
Prelude> r = 3
</code>
と何も考えずにやると
<code Plain Text>
Prelude> r = 3

<interactive>:9:1: parse error on input '='
</code>
怒られました．このあたりが python のインタープリタと根本的に違うところ，かなあ．<br />
これを回避するには
<code Plain Text>
Prelude> let r = 3
</code>
とやれば良く，以降もたまに使いますが，基本的には以下でやる通り，<br />
ソースファイルを作って読み込んでもらって interacitve にいろいろやっていく<br />
のがとりあえずは吉です． 
</p>
<p>
とりあえずこのあたりは一旦置いといて．変数定義はソースファイルから読み込んでやりましょう．<br />
<code>Varfun.hs</code> をつくる（Haskell の場合拡張子は .hs が普通みたい）．
<code Haskell>
r = 5.0
</code>
Haskell さん，こう見えて whitespace sensitive なので行頭にスペースは入れないように．<br />
なお <code>=</code> 前後のスペースはどうでも良い模様．<br />
で，これを GHCi から読み込むときには<code>:cd</code>で cd して <code>:load</code> か <code>:l</code>で読み込む．
<code Plain Text>
Prelude> :load Varfun.hs 
[1 of 1] Compiling Main             ( Varfun.hs, interpreted )
Ok, modules loaded: Main.
*Main> r
5.0
</code>
という感じですね．Tab 補完も効く模様．<br />
ghci を起動するときに引数として渡してやってもよいようだ．
<code Plain Text>
$ ghci Varfun.hs
GHCi, version 7.6.2: http://www.haskell.org/ghc/  :? for help
Loading package ghc-prim ... linking ... done.
Loading package integer-gmp ... linking ... done.
Loading package base ... linking ... done.
[1 of 1] Compiling Main             ( varfun.hs, interpreted )
Ok, modules loaded: Main.
*Main> 
</code>
変数名は小文字の英字で始めねばならず，残りは文字，数字，underscore (_), tick (') を使用できます．<br />
他の言語なら myfoo みたいな付け方をする場合には foo' とか使うのもいいかもしれません．<br />
そして，本来なら Haskell さんは静的格付け言語なのですが，型推論をやってくれるので今は無指定で大丈夫です．
</p>
<p>
もうちょっと書き足してみよう．エディタから<code>Varfun.hs</code>を編集
<code Haskell>
r = 5
area = pi*r^2
</code>
で ghci から <code>:reload</code> か <code>:r</code>で読み込み（引数は不要）．<br />
こんなかんじになるはず
<code Plain Text>
*Main> :r
[1 of 1] Compiling Main             ( Varfun.hs, interpreted )
Ok, modules loaded: Main.
*Main> area
78.53981633974483
*Main> area / r^2
3.141592653589793
*Main> </code>
めでたし． <br />
こうしてファイルから ghci に読み込むのじゃなくて， ghc でコンパイルすることも（もちろん）できます．<br />
そのへんもまたそのうちに．そのうちにっていうか
<code Plain Text>
$ ghc foo.hs
</code>
でいいんですけどね．
</p>

<h3>Comments</h3>
<p>Haskell のコメントは <code>--</code> に続けて書く(LaTeX の <code>%</code>, python の <code>#</code> 相当)．
<code Haskell>
x = 5     -- The variable x is 5.
y = 6     -- The variable y is 6.
-- z = 7
</code>
行の最後まで続かないの，あるいは複数行に渡るのは<code>{- comments -}</code>.
<code Haskell> x = {- Don't do this just because you can. -} 5 </code>
</p>

<h3>Variables in imperative languages</h3>
<p>
大事なこと言います．
<blockquote>
Haskell では，変数の値は変化しない．
</blockquote>
もう一度言います．
<blockquote><b>Variables do not vary.</b></blockquote>
大事なことだから三回目
<blockquote>
<pre><big><b>
＿人人人人人人人人人人人人＿
＞　変数の値は変化しない　＜
￣Y^Y^Y^Y^Y^Y^Y^Y^Y^Y^Y￣
</big></b></pre>
</blockquote>
<b>な，なんだってーーーーーー！！</b><br /><br />
</p>
<p>
<code>DoubleDeclarations.hs</code>
<code Haskell>
a = 3
a = 5
</code>
で
<code Plain Text>
Prelude> :l DoubleDeclarations.hs 
[1 of 1] Compiling Main             ( DoubleDeclarations.hs, interpreted )

DoubleDeclarations.hs:2:1:
    Multiple declarations of `a'
    Declared at: DoubleDeclarations.hs:1:1
                 DoubleDeclarations.hs:2:1
Failed, modules loaded: none. 
</code>
<i><code>Multiple declarations of `a'.</code></i><br />
<code> a </code> が2回定義されてるやん，おかしいやん，って言われてしまいました．<br />
<small>ちなみにこのように ghci のエラー表示は非常に親切かつ賢くて，丁寧に読むとかなり色々わかります，</small> <br />
これ，命令型言語なら， 1行目で a っていう ''箱'' に 3 が入り， 2行目で 5 になる，と読むところですが，<br />
我らが純粋関数型言語では，そうはならないわけです．数学で a = 3 って書いた時みたい．<br />
こんなのも：
<code> foo.hs </code> (ファイル名面倒になった)
<code Haskell>
a = 3
a = a+1
</code>
（これが動かないだと…!!）<br />
これは a の increment ではなく， a の再帰定義とみなされます．<br />
</p>
<p> 
これで直ちに嬉しいことの一つが，変数定義の順番を気にしなくて良いこと．
<code Haskell>
y = x*2
x = 3
</code>
と
<code Haskell>
x = 3
y = x*2
</code>
は同じ．もちろん y を実際に使うときには x の値が必要になりますが，<br />
そうして実際の特定の数値が必要になるまでは，べつに重要ではないというわけです．
</p>
<p>
でもそれどうするんですか，<code> for </code>文 loop とかどうすればいいんですか．<br />
→わくわくですよね．とにかく，ほんとにこれでうまく行くらしい． Haskell かっこいい．<br />
<small>実は，僕が Haskell をもうちょっとやろうと思った決定的な瞬間がこのあたりだったりします．<br />
すごくかっこよくて，すごく気持ちよさそう．もっと知りたいな，と思いました．それでいま勉強中．</small><br />
en.wikibooks から引用：
<blockquote><i>
By now, you probably look very incredulous and wonder how you can actually do anything at all in Haskell where variables don't change. But trust us; as we hope to show you in the rest of this book, you can write every program under the sun without ever changing a single variable!  In fact, variables that don't change make life so much easier because it makes programs much more predictable. It's a key feature of purely functional programming, not a bug.
</i></blockquote>
</p>
<h3> Functions </h3>
<p>
複数の円の面積を求めたい場合，
<code Haskell>
-- twoareas.hs
r = 5
area = pi*r^2
r2 = 3
area2 = pi*r2^2
</code>
…なんてやるのはあまりにひどい．ここで function の出番です．<p />
<p>
function は argument value (or parameter) をとって，結果の値を与えるもの．<br />
数学の函数と (Haskell でいう関数は！）一緒です．<br />
書き方はシンプル，variable 定義するのと同じノリで，左辺に argument を書いておく．
<code Haskell>
area r = pi * r^2 -- 数式っぽく書くなら A(r) = \pi * r^2
</code>
関数名，space あけて argument(s) で括弧は使わない．<br />
特別な syntax はない． r = 5 って定義したのと同じノリで，この書き方で定義する．<br />
</p>
<p>
さてではこれを call してみよう．とりあえずは ghci で読み込んで
<code Plain Text>
*Main> area 3
28.274333882308138
*Main> area 5
78.53981633974483
*Main> :t area
area :: Floating a => a -> a
</code>
<code> :t </code> のところ，まだ出てきてませんが type のことをやれば意味がわかるので少しお待ちを．
</p>
<p>
関数では括弧は使いませんが， expressions （値を与えるあらゆる code) を纏めて一緒に評価させるときに使われます．<br />
たとえば
<code Haskell>
area (5+3)
</code>
は最初に <code> 5+3 </code> （もちろん 8 ）を計算して，その <code> area </code> を計算します．一方
<code Haskell>
area 5 + 3
</code>
ではまず <code> area 5 </code> を計算して，それに <code> 3 </code> を足すことになります．<br />
これは掛け算が足し算より順位が高いのとおなじように， function call が先に行われるということです．<br />
では
<code Haskell>
area 5 * 3
area 1 ^ 3
</code>
はそれぞれどうなるでしょう．（演習課題？）
</p>
<p>
せっかくだから，もうちょっと関数を書いてみよう．
<code Haskell>
double x = 2 * x
quadruple x = double(double x)
square x = x * x
half x = x / 2
</code> 

</p> 
<h4> Evaluation </h4>
<p>
GHCi に expression を打ち込んだ時に何が起こるのか． <br />
Enter 押したら ghci は打ち込んだ expression を 評価 --evaluate-- します．<br />
これはつまり， 関数を定義で置き換え，結果を計算して，最後に値がひとつだけ残るまでそれをやる，ということ．<br />
さっきの <code> area 5 </code> でやってみましょうか．
<code Haskell>
    area 5
=>   {- 定義の area r = を 右辺の pi * r^2 で置き換え-}
    pi * 5^2
=> {- pi を数値に置き換え-}
    3.141592653589793 * 5^2
=> {- 指数(^)を適用 -}
    3.141592653589793 * 25
=> {- 掛け算 -}
    78.53981633974483
</code>
あ，別に <code> => </code> は Haskell さん的なアレじゃないよ．
</p>
<p>
練習問題．
<ul>
	<li> 少し前の <code> quadruple 5 </code> は ghci さんにどう評価されるか．再掲すると
<code Haskell>
double x = 2 * x
quadruple x  = double(double x)
</code>
	</li>
	<li>引数の半分から 12 を引く関数書いてみよう．</li>
</ul>
</p>
<h4> Multiple parameters </h4>
<p>
もちろん引数は一つとは限らないよー．縦と横与えられて長方形の面積：
<code Haskell>
areaRect l w = l * w
</code>
で
<code Plain Text>
*Main> areaRect 5 10
50
</code>
直角三角形の面積求めるぜ
<code Haskell>
areaRightTriangle b h = (b * h) /2
</code>
使うときはこんなかんじに引数同士をスペースで区切る．<br />
だから括弧使わないと誤解が生じることもあるわけですねー．
<code Haskell>
quadruple x = double double x
</code>
と，書くとします．実は関数も他の関数の引数になれちゃうので誤解が起きる．<br />
関数を関数に投げる話はまた後でするとして，とりあえずちゃんと誤解を解くために
<code Haskell>
quadruple x = double (double x)
</code>
としませう．<br />
一応確認しとくと順番は書いてあるままです．
<code Haskell>
subtract x y = x - y
</code>
なら<code> subtract 10 5 </code> は <code> 5 </code>, <code> subtract 5 10 </code> は <code> -5.</code>
なおいままで何の気無しに使ってた <code>+</code> とかも関数で，<code> (+) </code> と書くと本来の関数としての syntax で使えます．
<code Plain Text >
Prelude> (+) 3 2 
5
</code>
演習．
<ul>
	<li>直方体の体積出す関数書いてみよう．</li>
	<li>Giza のピラミッドって大体どのくらいの数の石でできてるだろう？ GHCi さんの助けを借りて計算してみよう．</li>
</ul>
</p>
<p>
関数使って関数作るのももちろんできるよ<br />
長方形と正方形の面積求めるもの
<code Haskell>
areaRect l w = l * w
areaSquare s = areaRect s s
</code>
こういうのできるの，後々わかってくるけど超便利．<br />
演習．
<ul>
<li> 円柱の体積求める関数書いてみよう．</li>
</ul>
</p>
<h3> Local definitions </h3>
<h4> <code>where</code> clauses </h4>
<p>
その関数の中でしか使わへんようなやつをいちいちきちんと定義するのもアレなので．<br />
Heron の公式 ($ A = \sqrt{s (s-a) (s-b) (s-c)} $ where $ s = (a+b+c)/2 $) 
<code Haskell>
heron a b c = sqrt ( s*(s-a)*(s-b)*(s-c) )
    where 
    s = (a+b+c) / 2
</code>
<code>where</code> と local definitions はスペース4つでインデントして区別されます．<br />
このへん python みたいに whitespace sensitive なわけですねー．<br />
そしてこれを，
<code Haskell>
heron a b c = sqrt ( s*(s-a)*(s-b)*(s-c) ) -- s はここでは定義されてない
s = (a+b+c) / 2  -- ここでは a, b, c が定義されてない
</code>
と書くと，<code> s = (a+b+c)/2 </code> のところは <code> heron </code> の右辺の定義の一部としては解釈されないので，<br />
所定の結果は得られません．
</p>
<p>他の例．
<code Haskell>
areaTriangleTrig a b c = c * height / 2 --三角関数で
    where
    cosa = (b^2 + c^2 - a^2) / (2*b*c) --余弦定理
    sina = sqrt(1 - cosa^2)
	height = b * sina
areaTriangleHeron a b c = result --ヘロンの公式から
    where
    result = sqrt(s*(s-a)*(s-b)*(s-c))
    s = (a+b+c) / 2
</code>
</p>
<h4> Scope </h4>
<p>
上の例で <code> a </code> とか <code> b </code> とか <code> c </code> とかたくさん出てきたけど，大丈夫なんか．<br />
これはありがたいことに思ったとおりに動く：(<code>let</code> のことは一旦おいといて．)
<code Plain Text>
Prelude> let r = 0
Prelude> let area r = pi * r^2
Prelude> area 5
</code>
最初に <code>r = 0</code> といってるから <code>area r = pi * r^2</code> で問答無用に 0や! とはなりません．<br />
要するに 2つの<code> r </code> は別のものを指してるというわけ．<br />
詳しくはここでは省くけど， scope っていう（他の言語にもあるよね）仕組みで上手くいくようになってるかんじです．<br />
つまり，<code>=</code> で結ぶと，以降その定義の scope に照らして適切である範囲で右辺と置き換えられる，みたいな．<br />
感じ．詳細がなくてすっきりしないけど．
</p>
<h2> Truth Values</h2>
<h3> Equality and other comparisons / Boolean Values  </h3>
<p>
アレだ，数学で <code>=</code> って書いてもどっちかいうと proposition としてのそれがあるようなかんじで．
2つの値の比較には <code>==</code> を使う．
<code Plain Text>
Prelude> 2 + 3 == 5
True
</code>
あるいは <code>False</code> が帰ってくる．大小比較は <code> >, <, <=, >=</code> で．
<code Plain Text>
Main*> area 5 < 50
</code>
みたいな書き方ももちろん出来ます．<br />
帰ってくる値は Boolean values, ないし truth values.
</p>

<h3> An introduction to types </h3>
<p>
Type の話だ！楽しみにしましょう！わーい！<br />
Truth values が values というてるけど，これはマジでそういうことで， 数値と同じ意味で値を持ってる．<br />
例えば
<code Plain Text>
Prelude> True == True
True
Prelude> True == False
False
</code>
ってな感じ．では「2 と True は等しいでしょうか？」
<code Plain Text>
Prelude> 2 == True

<interactive>:3:1:
    No instance for (Num Bool) arising from the literal `2'
    Possible fix: add an instance declaration for (Num Bool)
    In the first argument of `(==)', namely `2'
    In the expression: 2 == True
    In an equation for `it': it = 2 == True
</code>
そんな比較はできません．<small>上で ghci さんが何を言ってるのかは後ほど読めるようになる．</small><br />
左辺は数 (type としては <code>Num</code>), 右辺は Boolean value (<code>Bool</code>)<br />
型 (type) が違うので，比較のしようがないのです．<br />
これまでは ghci が勝手に解釈してくれていましたが，自分で型を指定することもでき，<br />
Haskell のこの型システムは，ちゃんと意味が通るように物事を動かす上で非常に強力です．<br />
超大事で格好いいので次の章はこの型の話．その前に今の話を片付けてしまいましょう． 
</p>
<h3> Infix operators </h3>
<p>
さっきの 2 と True を調べた時，
<code Plain Text>
In the first argument of `(==)', namely `2'
</code>
さて ghc さんは 2 を first argument of (==) と呼んでるわけやけれども，この (==) も普通の函数．<br />
ただ syntax 的にちょっと違って， Haskell ではこういう，<br />
名前が英数以外の記号だけでできてる 2 変数関数 は中置できることになってるらしい．<br />
infix operators, と呼ぶそうな．普通の関数みたいに使うときは ( ) でくくる．
<code Plain Text>
Prelude (==) (4 + 9) 13
True
</code>
逆にさっきの <code>areaRect</code> みたいな関数を中置したい時は ` `  でくくって
<code Haskell>
2 `areaRect` 5
</code>
と書ける．これではあんまり嬉しさもないけど，<code>3 `mod` 2</code> みたいな書き方は素敵そう．<br />
というわけで <code>==</code> も <code>+</code> も <code> >= </code> もなんでもかんでも関数です．
</p>
<h3> Boolean operations </h3>
and は <code>(&&)</code>, or は <code>(||)</code>, <code>not</code> で論理否定．<br />
いずれもさっきの infix operator な記法に従います．
<code Plain Text>
Prelude> (3 < 8) && (False == False)
True
Prelude> (&&) (3 < 8) (False == False)
True
Prelude> not (5*2 == 10)
False
</code>
みたいな感じ．なお， not equal to については <code>/=</code> (\neq に形を似せたという噂？) とも書ける．あえて書くなら<br />
<code Haskell>
x /= y = not (x == y)
</code>
というかんじ（この書き方で完全に正しい）．
<h3> Guards </h3>
